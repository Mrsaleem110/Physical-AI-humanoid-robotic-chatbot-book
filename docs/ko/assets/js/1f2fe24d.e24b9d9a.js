"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[123],{8162:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module-3/isaac-sim-photorealistic","title":"Isaac Sim Photorealistic Simulation","description":"Chapter Objectives","source":"@site/docs/module-3/isaac-sim-photorealistic.md","sourceDirName":"module-3","slug":"/module-3/isaac-sim-photorealistic","permalink":"/Physical-AI-humanoid-robotic-chatbot-book/ko/docs/module-3/isaac-sim-photorealistic","draft":false,"unlisted":false,"editUrl":"https://github.com/Mrsaleem110/Physical-AI-humanoid-robotic-chatbot-book/tree/main/docs/docs/module-3/isaac-sim-photorealistic.md","tags":[],"version":"current","lastUpdatedBy":"muhammad_saleem","lastUpdatedAt":1765979454000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Sensor Simulation: LiDAR, Depth Camera, IMU","permalink":"/Physical-AI-humanoid-robotic-chatbot-book/ko/docs/module-2/sensor-simulation"},"next":{"title":"Isaac Sim Synthetic Data Generation","permalink":"/Physical-AI-humanoid-robotic-chatbot-book/ko/docs/module-3/synthetic-data-generation"}}');var t=n(4848),a=n(8453);const s={sidebar_position:1},o="Isaac Sim Photorealistic Simulation",l={},d=[{value:"Chapter Objectives",id:"chapter-objectives",level:2},{value:"Introduction to NVIDIA Isaac Sim",id:"introduction-to-nvidia-isaac-sim",level:2},{value:"Key Features of Isaac Sim",id:"key-features-of-isaac-sim",level:3},{value:"Why Isaac Sim for Humanoid Robotics?",id:"why-isaac-sim-for-humanoid-robotics",level:3},{value:"Isaac Sim Architecture",id:"isaac-sim-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"USD (Universal Scene Description)",id:"usd-universal-scene-description",level:3},{value:"Setting Up Isaac Sim",id:"setting-up-isaac-sim",level:2},{value:"Installation Requirements",id:"installation-requirements",level:3},{value:"Basic Launch Script",id:"basic-launch-script",level:3},{value:"Creating High-Fidelity Robot Models",id:"creating-high-fidelity-robot-models",level:2},{value:"Robot Model Structure in Isaac Sim",id:"robot-model-structure-in-isaac-sim",level:3},{value:"Creating a Humanoid Robot",id:"creating-a-humanoid-robot",level:3},{value:"Photorealistic Rendering Techniques",id:"photorealistic-rendering-techniques",level:2},{value:"Material Definition Language (MDL)",id:"material-definition-language-mdl",level:3},{value:"Lighting Setup",id:"lighting-setup",level:3},{value:"Environment Creation",id:"environment-creation",level:2},{value:"Creating Complex Environments",id:"creating-complex-environments",level:3},{value:"Sensor Integration in Isaac Sim",id:"sensor-integration-in-isaac-sim",level:2},{value:"High-Fidelity Sensor Simulation",id:"high-fidelity-sensor-simulation",level:3},{value:"Advanced Rendering Features",id:"advanced-rendering-features",level:2},{value:"Physically-Based Rendering (PBR)",id:"physically-based-rendering-pbr",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Multi-Level of Detail (MLOD)",id:"multi-level-of-detail-mlod",level:3},{value:"Best Practices for Photorealistic Simulation",id:"best-practices-for-photorealistic-simulation",level:2},{value:"Scene Optimization",id:"scene-optimization",level:3},{value:"Material Best Practices",id:"material-best-practices",level:3},{value:"Sensor Simulation Accuracy",id:"sensor-simulation-accuracy",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2},{value:"Summary",id:"summary",level:2},{value:"Learning Path Adjustment",id:"learning-path-adjustment",level:2}];function c(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"isaac-sim-photorealistic-simulation",children:"Isaac Sim Photorealistic Simulation"})}),"\n",(0,t.jsx)(r.h2,{id:"chapter-objectives",children:"Chapter Objectives"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Understand NVIDIA Isaac Sim architecture and capabilities"}),"\n",(0,t.jsx)(r.li,{children:"Set up photorealistic simulation environments"}),"\n",(0,t.jsx)(r.li,{children:"Create high-fidelity robot models for Isaac Sim"}),"\n",(0,t.jsx)(r.li,{children:"Implement advanced rendering and lighting techniques"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"introduction-to-nvidia-isaac-sim",children:"Introduction to NVIDIA Isaac Sim"}),"\n",(0,t.jsx)(r.p,{children:"NVIDIA Isaac Sim is a robotics simulator that provides:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Photorealistic Rendering"}),": Using NVIDIA Omniverse for physically-based rendering"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"PhysX Integration"}),": High-fidelity physics simulation"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Synthetic Data Generation"}),": For training AI models"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Isaac ROS Integration"}),": Direct integration with ROS 2"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"AI Training Environment"}),": Built for machine learning applications"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"key-features-of-isaac-sim",children:"Key Features of Isaac Sim"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Omniverse Platform"}),": Based on NVIDIA's real-time 3D design collaboration platform"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"PhysX Physics Engine"}),": Advanced physics simulation with GPU acceleration"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Material Definition Language (MDL)"}),": Physically accurate materials"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Deep Learning Integration"}),": Support for reinforcement learning and perception training"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"ROS 2 Bridge"}),": Seamless integration with ROS 2 ecosystem"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"why-isaac-sim-for-humanoid-robotics",children:"Why Isaac Sim for Humanoid Robotics?"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Realistic Perception"}),": High-fidelity sensors for vision-based AI"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Physics Accuracy"}),": Realistic contact and collision dynamics"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Lighting Simulation"}),": Physically-based lighting affecting sensors"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Synthetic Data"}),": Large datasets for AI model training"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Scalability"}),": Can run on single workstations to data centers"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"isaac-sim-architecture",children:"Isaac Sim Architecture"}),"\n",(0,t.jsx)(r.h3,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"Isaac Sim Architecture:\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502              Omniverse Core             \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502  PhysX Physics Engine + GPU Acceleration\u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     USD Scene Representation            \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502      Sensor Simulation                  \u2502\r\n\u2502    (Cameras, LiDAR, IMU, etc.)         \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502        ROS 2 Interface                  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502    AI Training & Synthetic Data         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(r.h3,{id:"usd-universal-scene-description",children:"USD (Universal Scene Description)"}),"\n",(0,t.jsx)(r.p,{children:"USD is the scene description language used by Isaac Sim:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# Example Python code to create a USD stage in Isaac Sim\r\nimport omni\r\nfrom pxr import Usd, UsdGeom, Gf, Sdf\r\n\r\n# Create a new stage\r\nstage = Usd.Stage.CreateNew("humanoid_robot.usd")\r\n\r\n# Create a root prim\r\nworld_prim = stage.DefinePrim("/World", "Xform")\r\n\r\n# Create a robot body\r\nrobot_prim = stage.DefinePrim("/World/Robot", "Xform")\r\n\r\n# Add a link to the robot\r\nbody_link = stage.DefinePrim("/World/Robot/Body", "Xform")\r\nmesh = UsdGeom.Mesh.Define(stage, "/World/Robot/Body/Mesh")\r\n\r\n# Set mesh properties\r\nmesh.CreatePointsAttr([Gf.Vec3f(-0.5, -0.5, -0.5), Gf.Vec3f(0.5, -0.5, -0.5), ...])\r\nmesh.CreateFaceVertexCountsAttr([4])\r\nmesh.CreateFaceVertexIndicesAttr([0, 1, 2, 3])\r\n\r\n# Save the stage\r\nstage.GetRootLayer().Save()\n'})}),"\n",(0,t.jsx)(r.h2,{id:"setting-up-isaac-sim",children:"Setting Up Isaac Sim"}),"\n",(0,t.jsx)(r.h3,{id:"installation-requirements",children:"Installation Requirements"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-bash",children:"# System requirements\r\n# - NVIDIA GPU with CUDA support (RTX series recommended)\r\n# - Ubuntu 20.04 or Windows 10/11\r\n# - At least 16GB RAM, 32GB+ recommended\r\n# - NVIDIA driver 495.44 or newer\r\n\r\n# Install Isaac Sim (typically done through Omniverse Launcher)\r\n# Download from NVIDIA Developer website\n"})}),"\n",(0,t.jsx)(r.h3,{id:"basic-launch-script",children:"Basic Launch Script"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# launch_isaac_sim.py\r\nimport omni\r\nfrom omni.isaac.core import World\r\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\r\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\r\nfrom omni.isaac.core.utils.prims import get_prim_at_path\r\nimport carb\r\n\r\n# Create a world instance\r\nworld = World(stage_units_in_meters=1.0)\r\n\r\n# Add a robot from the NVIDIA Isaac Sim assets\r\nassets_root_path = get_assets_root_path()\r\nif assets_root_path is None:\r\n    carb.log_error("Could not find Isaac Sim assets. Please check your Isaac Sim installation.")\r\n\r\n# Example: Adding a simple robot\r\nrobot_path = assets_root_path + "/Isaac/Robots/Franka/fr3.usd"\r\nadd_reference_to_stage(usd_path=robot_path, prim_path="/World/Robot")\r\n\r\n# Reset the world to apply changes\r\nworld.reset()\r\n\r\n# Run simulation\r\nfor i in range(1000):\r\n    world.step(render=True)\r\n    if i % 100 == 0:\r\n        print(f"Simulation step {i}")\r\n\r\n# Cleanup\r\nworld.clear()\n'})}),"\n",(0,t.jsx)(r.h2,{id:"creating-high-fidelity-robot-models",children:"Creating High-Fidelity Robot Models"}),"\n",(0,t.jsx)(r.h3,{id:"robot-model-structure-in-isaac-sim",children:"Robot Model Structure in Isaac Sim"}),"\n",(0,t.jsx)(r.p,{children:"In Isaac Sim, robots are defined using:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"USD Prims"}),": Basic building blocks"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Rigid Bodies"}),": For physics simulation"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Joints"}),": For articulation"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Sensors"}),": For perception"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Materials"}),": For photorealistic rendering"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"creating-a-humanoid-robot",children:"Creating a Humanoid Robot"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# humanoid_robot.py\r\nimport omni\r\nfrom omni.isaac.core import World\r\nfrom omni.isaac.core.robots import Robot\r\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\r\nfrom omni.isaac.core.utils.prims import create_prim\r\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\r\nfrom pxr import Gf, UsdGeom, PhysxSchema\r\nimport numpy as np\r\n\r\nclass HumanoidRobot(Robot):\r\n    def __init__(\r\n        self,\r\n        prim_path: str,\r\n        name: str = "humanoid_robot",\r\n        usd_path: str = None,\r\n        position: np.ndarray = np.array([0.0, 0.0, 0.0]),\r\n        orientation: np.ndarray = np.array([0.0, 0.0, 0.0, 1.0]),\r\n    ) -> None:\r\n        self._usd_path = usd_path\r\n        self._name = name\r\n\r\n        super().__init__(\r\n            prim_path=prim_path,\r\n            name=name,\r\n            position=position,\r\n            orientation=orientation,\r\n        )\r\n\r\n    def add_to_stage(self, stage, prefix=None):\r\n        """Add humanoid robot to stage"""\r\n        if self._usd_path:\r\n            add_reference_to_stage(self._usd_path, self.prim_path)\r\n        else:\r\n            # Create a simple humanoid model from primitives\r\n            self._create_simple_humanoid()\r\n\r\n    def _create_simple_humanoid(self):\r\n        """Create a simple humanoid robot using USD prims"""\r\n        # Create body parts\r\n        self._create_body_part("torso", [0.0, 0.0, 1.0], [0.3, 0.3, 0.6])\r\n        self._create_body_part("head", [0.0, 0.0, 1.45], [0.2, 0.2, 0.2])\r\n        self._create_body_part("left_arm_upper", [-0.2, 0.0, 1.2], [0.08, 0.08, 0.4])\r\n        self._create_body_part("left_arm_lower", [-0.2, 0.0, 0.9], [0.06, 0.06, 0.35])\r\n        self._create_body_part("right_arm_upper", [0.2, 0.0, 1.2], [0.08, 0.08, 0.4])\r\n        self._create_body_part("right_arm_lower", [0.2, 0.0, 0.9], [0.06, 0.06, 0.35])\r\n        self._create_body_part("left_leg_upper", [-0.1, 0.0, 0.5], [0.09, 0.09, 0.5])\r\n        self._create_body_part("left_leg_lower", [-0.1, 0.0, 0.1], [0.08, 0.08, 0.4])\r\n        self._create_body_part("right_leg_upper", [0.1, 0.0, 0.5], [0.09, 0.09, 0.5])\r\n        self._create_body_part("right_leg_lower", [0.1, 0.0, 0.1], [0.08, 0.08, 0.4])\r\n        self._create_body_part("left_foot", [-0.1, 0.0, -0.15], [0.15, 0.1, 0.06])\r\n        self._create_body_part("right_foot", [0.1, 0.0, -0.15], [0.15, 0.1, 0.06])\r\n\r\n    def _create_body_part(self, name, position, size):\r\n        """Create a single body part"""\r\n        # Create a rigid body prim\r\n        prim_path = f"{self.prim_path}/{name}"\r\n        create_prim(\r\n            prim_path=prim_path,\r\n            prim_type="Xform",\r\n            position=position\r\n        )\r\n\r\n        # Add collision and visual shapes\r\n        collision_path = f"{prim_path}/collision"\r\n        visual_path = f"{prim_path}/visual"\r\n\r\n        # Collision mesh (simplified for performance)\r\n        create_prim(\r\n            prim_path=collision_path,\r\n            prim_type="Cube",\r\n            position=[0, 0, 0],\r\n            attributes={"size": min(size)}\r\n        )\r\n\r\n        # Visual mesh (detailed for rendering)\r\n        create_prim(\r\n            prim_path=visual_path,\r\n            prim_type="Cube",\r\n            position=[0, 0, 0],\r\n            attributes={"size": min(size)}\r\n        )\r\n\r\n        # Apply physics properties\r\n        self._apply_physics_properties(prim_path, size)\r\n\r\n    def _apply_physics_properties(self, prim_path, size):\r\n        """Apply physics properties to a prim"""\r\n        # Calculate mass based on size (assuming density of 1000 kg/m^3)\r\n        volume = size[0] * size[1] * size[2]\r\n        mass = volume * 1000  # kg\r\n\r\n        # Get the prim and apply rigid body properties\r\n        prim = get_prim_at_path(prim_path)\r\n        rigid_api = PhysxSchema.PhysxConeAttachmentAPI.Apply(prim)\r\n\r\n        # Set mass properties\r\n        rigid_api.GetMassAttr().Set(mass)\r\n\r\n# Example usage\r\ndef create_humanoid_world():\r\n    world = World(stage_units_in_meters=1.0)\r\n\r\n    # Create and add humanoid robot\r\n    robot = HumanoidRobot(\r\n        prim_path="/World/HumanoidRobot",\r\n        name="humanoid_robot",\r\n        position=np.array([0.0, 0.0, 0.5])\r\n    )\r\n\r\n    world.scene.add(robot)\r\n\r\n    # Add ground plane\r\n    world.scene.add_default_ground_plane()\r\n\r\n    return world, robot\n'})}),"\n",(0,t.jsx)(r.h2,{id:"photorealistic-rendering-techniques",children:"Photorealistic Rendering Techniques"}),"\n",(0,t.jsx)(r.h3,{id:"material-definition-language-mdl",children:"Material Definition Language (MDL)"}),"\n",(0,t.jsx)(r.p,{children:"MDL is used for physically accurate materials in Isaac Sim:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-mdl",children:"// Example MDL material definition for humanoid robot\r\nmdl {\r\n  material humanoid_metal =\r\n    mdl::surface(\r\n      base = color(0.8, 0.8, 0.9),\r\n      metallic = 0.7,\r\n      roughness = 0.2,\r\n      normal = texture::get_normal()\r\n    );\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"lighting-setup",children:"Lighting Setup"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# lighting_setup.py\r\nfrom omni.isaac.core.utils.prims import create_prim\r\nfrom omni.isaac.core.utils.stage import get_current_stage\r\nfrom pxr import UsdLux, Gf\r\n\r\ndef setup_photorealistic_lighting():\r\n    """Set up photorealistic lighting for the scene"""\r\n    stage = get_current_stage()\r\n\r\n    # Create dome light for environment lighting\r\n    dome_light = UsdLux.DomeLight.Define(stage, "/World/DomeLight")\r\n    dome_light.CreateIntensityAttr(1000)\r\n    dome_light.CreateTextureFileAttr("path/to/hdr/environment.hdr")\r\n\r\n    # Create key light (main light source)\r\n    key_light = UsdLux.DistantLight.Define(stage, "/World/KeyLight")\r\n    key_light.AddTranslateOp().Set(Gf.Vec3f(5, 5, 10))\r\n    key_light.CreateIntensityAttr(3000)\r\n    key_light.CreateColorAttr(Gf.Vec3f(1.0, 0.98, 0.9))\r\n\r\n    # Create fill light (softens shadows)\r\n    fill_light = UsdLux.DistantLight.Define(stage, "/World/FillLight")\r\n    fill_light.AddTranslateOp().Set(Gf.Vec3f(-3, 2, 5))\r\n    fill_light.CreateIntensityAttr(1000)\r\n    fill_light.CreateColorAttr(Gf.Vec3f(0.8, 0.85, 1.0))\r\n\r\ndef setup_sensor_lighting():\r\n    """Set up lighting specifically for sensor simulation"""\r\n    stage = get_current_stage()\r\n\r\n    # Create lighting that affects sensor data\r\n    sensor_light = UsdLux.RectLight.Define(stage, "/World/SensorLight")\r\n    sensor_light.CreateWidthAttr(2.0)\r\n    sensor_light.CreateHeightAttr(2.0)\r\n    sensor_light.CreateIntensityAttr(500)\r\n    sensor_light.CreateColorAttr(Gf.Vec3f(1.0, 1.0, 1.0))\r\n    sensor_light.AddTranslateOp().Set(Gf.Vec3f(0, 0, 3))\n'})}),"\n",(0,t.jsx)(r.h2,{id:"environment-creation",children:"Environment Creation"}),"\n",(0,t.jsx)(r.h3,{id:"creating-complex-environments",children:"Creating Complex Environments"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# environment_creation.py\r\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\r\nfrom omni.isaac.core.utils.prims import create_prim\r\nfrom pxr import Gf, UsdGeom\r\nimport numpy as np\r\n\r\ndef create_office_environment():\r\n    """Create a photorealistic office environment"""\r\n\r\n    # Create office floor\r\n    create_prim(\r\n        prim_path="/World/OfficeFloor",\r\n        prim_type="Plane",\r\n        position=[0, 0, 0],\r\n        attributes={"size": 20.0}\r\n    )\r\n\r\n    # Add realistic floor material\r\n    floor_material = create_prim(\r\n        prim_path="/World/Looks/FloorMaterial",\r\n        prim_type="Material"\r\n    )\r\n\r\n    # Add office furniture\r\n    add_office_furniture()\r\n\r\n    # Add realistic textures and materials\r\n    apply_realistic_materials()\r\n\r\ndef add_office_furniture():\r\n    """Add realistic office furniture"""\r\n    # Desk\r\n    create_prim(\r\n        prim_path="/World/Desk",\r\n        prim_type="Cube",\r\n        position=[3, 0, 0.75],\r\n        attributes={"size": 2.0}\r\n    )\r\n\r\n    # Chair\r\n    create_prim(\r\n        prim_path="/World/Chair",\r\n        prim_type="Cylinder",\r\n        position=[2, -1, 0.5],\r\n        attributes={"radius": 0.3, "height": 1.0}\r\n    )\r\n\r\n    # Bookshelf\r\n    create_prim(\r\n        prim_path="/World/Bookshelf",\r\n        prim_type="Cube",\r\n        position=[-4, 2, 1.0],\r\n        attributes={"size": 1.5}\r\n    )\r\n\r\ndef apply_realistic_materials():\r\n    """Apply realistic materials to environment objects"""\r\n    # This would involve setting up MDL materials for realistic surfaces\r\n    # such as wood, metal, glass, fabric, etc.\r\n    pass\r\n\r\ndef create_warehouse_environment():\r\n    """Create a warehouse environment with realistic lighting"""\r\n\r\n    # Large floor area\r\n    create_prim(\r\n        prim_path="/World/WarehouseFloor",\r\n        prim_type="Plane",\r\n        position=[0, 0, 0],\r\n        attributes={"size": 50.0}\r\n    )\r\n\r\n    # Industrial lighting\r\n    for i in range(10):\r\n        for j in range(5):\r\n            create_prim(\r\n                prim_path=f"/World/Lights/HangLight_{i}_{j}",\r\n                prim_type="Sphere",\r\n                position=[i*5 - 20, j*8 - 16, 8],\r\n                attributes={"radius": 0.2}\r\n            )\r\n\r\n    # Pallets and boxes\r\n    for i in range(20):\r\n        create_prim(\r\n            prim_path=f"/World/Pallet_{i}",\r\n            prim_type="Cube",\r\n            position=[np.random.uniform(-20, 20), np.random.uniform(-20, 20), 0.1],\r\n            attributes={"size": 1.2}\r\n        )\n'})}),"\n",(0,t.jsx)(r.h2,{id:"sensor-integration-in-isaac-sim",children:"Sensor Integration in Isaac Sim"}),"\n",(0,t.jsx)(r.h3,{id:"high-fidelity-sensor-simulation",children:"High-Fidelity Sensor Simulation"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# sensor_integration.py\r\nfrom omni.isaac.sensor import Camera, RayFrameReader\r\nfrom omni.isaac.range_sensor import LidarRtx\r\nimport numpy as np\r\n\r\nclass IsaacSensors:\r\n    def __init__(self, robot_prim_path):\r\n        self.robot_prim_path = robot_prim_path\r\n        self.cameras = []\r\n        self.lidars = []\r\n        self.imus = []\r\n\r\n    def add_rgb_camera(self, name, position, orientation):\r\n        """Add a high-fidelity RGB camera"""\r\n        camera = Camera(\r\n            prim_path=f"{self.robot_prim_path}/{name}",\r\n            position=position,\r\n            orientation=orientation,\r\n            resolution=(1920, 1080),\r\n            frequency=30\r\n        )\r\n\r\n        # Configure camera properties for photorealism\r\n        camera.get_sensor().set_focal_length(24.0)  # mm\r\n        camera.get_sensor().set_horizontal_aperture(36.0)  # mm\r\n        camera.get_sensor().set_f_stop(2.8)\r\n\r\n        self.cameras.append(camera)\r\n        return camera\r\n\r\n    def add_lidar(self, name, position, orientation):\r\n        """Add a high-fidelity LiDAR sensor"""\r\n        lidar = LidarRtx(\r\n            prim_path=f"{self.robot_prim_path}/{name}",\r\n            position=position,\r\n            orientation=orientation,\r\n            config="Solid-State-Mixed",\r\n            min_range=0.1,\r\n            max_range=25.0,\r\n            fov=360\r\n        )\r\n\r\n        # Configure LiDAR for photorealistic simulation\r\n        lidar.set_max_rays_in_flight(64000000)  # High performance mode\r\n        lidar.set_laser_offset([0.0, 0.0, 0.0])\r\n\r\n        self.lidars.append(lidar)\r\n        return lidar\r\n\r\n    def add_imu(self, name, position, orientation):\r\n        """Add an IMU sensor"""\r\n        # IMU integration in Isaac Sim typically uses contact sensors\r\n        # and rigid body dynamics for realistic inertial measurements\r\n        imu_prim_path = f"{self.robot_prim_path}/{name}"\r\n\r\n        # Create IMU as a reference to a rigid body\r\n        create_prim(\r\n            prim_path=imu_prim_path,\r\n            prim_type="Xform",\r\n            position=position\r\n        )\r\n\r\n        self.imus.append(imu_prim_path)\r\n        return imu_prim_path\r\n\r\n    def capture_sensor_data(self):\r\n        """Capture data from all sensors"""\r\n        sensor_data = {}\r\n\r\n        # Capture camera data\r\n        for camera in self.cameras:\r\n            rgb_data = camera.get_rgb()\r\n            depth_data = camera.get_depth()\r\n            sensor_data[camera.name] = {\r\n                "rgb": rgb_data,\r\n                "depth": depth_data\r\n            }\r\n\r\n        # Capture LiDAR data\r\n        for lidar in self.lidars:\r\n            point_cloud = lidar.get_point_cloud()\r\n            sensor_data[lidar.name] = {\r\n                "point_cloud": point_cloud\r\n            }\r\n\r\n        return sensor_data\r\n\r\ndef setup_robot_sensors(robot_path):\r\n    """Setup sensors for the humanoid robot"""\r\n    sensors = IsaacSensors(robot_path)\r\n\r\n    # Add head-mounted RGB-D camera\r\n    sensors.add_rgb_camera(\r\n        name="head_camera",\r\n        position=[0, 0, 0.1],  # Position relative to head\r\n        orientation=[0, 0, 0, 1]\r\n    )\r\n\r\n    # Add LiDAR to torso\r\n    sensors.add_lidar(\r\n        name="torso_lidar",\r\n        position=[0, 0, 0.2],  # Position relative to torso\r\n        orientation=[0, 0, 0, 1]\r\n    )\r\n\r\n    # Add IMU to torso\r\n    sensors.add_imu(\r\n        name="torso_imu",\r\n        position=[0, 0, 0],  # Position relative to torso\r\n        orientation=[0, 0, 0, 1]\r\n    )\r\n\r\n    return sensors\n'})}),"\n",(0,t.jsx)(r.h2,{id:"advanced-rendering-features",children:"Advanced Rendering Features"}),"\n",(0,t.jsx)(r.h3,{id:"physically-based-rendering-pbr",children:"Physically-Based Rendering (PBR)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# pbr_materials.py\r\ndef create_pbr_materials():\r\n    """Create physically-based materials for realistic rendering"""\r\n\r\n    # Robot body material (metallic)\r\n    robot_body_material = {\r\n        "albedo": [0.8, 0.8, 0.9],      # Base color\r\n        "metallic": 0.8,                # Metallic property\r\n        "roughness": 0.2,               # Surface roughness\r\n        "specular": 0.5,                # Specular reflection\r\n        "normal_scale": 1.0             # Normal map strength\r\n    }\r\n\r\n    # Rubber material for feet\r\n    rubber_material = {\r\n        "albedo": [0.2, 0.2, 0.2],      # Dark rubber color\r\n        "metallic": 0.0,                # Non-metallic\r\n        "roughness": 0.9,               # Very rough surface\r\n        "specular": 0.1,                # Low specular\r\n        "clearcoat": 0.3,               # Slight coating\r\n        "clearcoat_roughness": 0.2\r\n    }\r\n\r\n    # Plastic material for face/hands\r\n    plastic_material = {\r\n        "albedo": [0.9, 0.7, 0.5],      # Skin-like color\r\n        "metallic": 0.0,                # Non-metallic\r\n        "roughness": 0.4,               # Medium roughness\r\n        "subsurface": 0.1               # Slight subsurface scattering\r\n    }\r\n\r\n    return {\r\n        "robot_body": robot_body_material,\r\n        "rubber": rubber_material,\r\n        "plastic": plastic_material\r\n    }\r\n\r\ndef apply_advanced_materials(stage):\r\n    """Apply advanced materials to objects in the stage"""\r\n    materials = create_pbr_materials()\r\n\r\n    # Apply materials to robot parts\r\n    apply_material_to_prim(stage, "/World/HumanoidRobot/Body", materials["robot_body"])\r\n    apply_material_to_prim(stage, "/World/HumanoidRobot/LeftFoot", materials["rubber"])\r\n    apply_material_to_prim(stage, "/World/HumanoidRobot/RightFoot", materials["rubber"])\r\n    apply_material_to_prim(stage, "/World/HumanoidRobot/Head", materials["plastic"])\r\n\r\ndef apply_material_to_prim(stage, prim_path, material_props):\r\n    """Apply material properties to a USD prim"""\r\n    # This would involve creating USD material nodes and connecting them\r\n    # to the appropriate geometry\r\n    pass\n'})}),"\n",(0,t.jsx)(r.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(r.h3,{id:"multi-level-of-detail-mlod",children:"Multi-Level of Detail (MLOD)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# performance_optimization.py\r\nclass PerformanceOptimizer:\r\n    def __init__(self, world):\r\n        self.world = world\r\n        self.lod_levels = ["high", "medium", "low", "proxy"]\r\n        self.current_lod = "high"\r\n\r\n    def adjust_simulation_lod(self, distance_to_camera):\r\n        """Adjust simulation detail based on distance"""\r\n        if distance_to_camera > 20:\r\n            self.set_lod("proxy")\r\n        elif distance_to_camera > 10:\r\n            self.set_lod("low")\r\n        elif distance_to_camera > 5:\r\n            self.set_lod("medium")\r\n        else:\r\n            self.set_lod("high")\r\n\r\n    def set_lod(self, level):\r\n        """Set the level of detail for simulation"""\r\n        if level == self.current_lod:\r\n            return\r\n\r\n        self.current_lod = level\r\n\r\n        if level == "high":\r\n            # Full physics, detailed rendering, all sensors active\r\n            self.world.get_physics_context().set_simulation_dt(1.0/60.0)\r\n            self.enable_all_sensors()\r\n        elif level == "medium":\r\n            # Reduced physics steps, less detailed rendering\r\n            self.world.get_physics_context().set_simulation_dt(1.0/30.0)\r\n            self.reduce_sensor_resolution()\r\n        elif level == "low":\r\n            # Simplified physics, basic rendering\r\n            self.world.get_physics_context().set_simulation_dt(1.0/15.0)\r\n            self.disable_complex_sensors()\r\n        elif level == "proxy":\r\n            # Simplified representation, minimal physics\r\n            self.world.get_physics_context().set_simulation_dt(1.0/10.0)\r\n            self.use_proxy_models()\r\n\r\n    def enable_all_sensors(self):\r\n        """Enable all sensor simulations"""\r\n        pass\r\n\r\n    def reduce_sensor_resolution(self):\r\n        """Reduce sensor resolution for performance"""\r\n        pass\r\n\r\n    def disable_complex_sensors(self):\r\n        """Disable complex sensors"""\r\n        pass\r\n\r\n    def use_proxy_models(self):\r\n        """Use simplified proxy models"""\r\n        pass\r\n\r\ndef setup_performance_monitoring():\r\n    """Setup performance monitoring for Isaac Sim"""\r\n    import carb\r\n    import omni.kit.app as app\r\n\r\n    # Enable performance monitoring\r\n    carb.settings.get_settings().set("/app/window/dpiScale", 1.0)\r\n    carb.settings.get_settings().set("/persistent/isaac/app/window/profiling", True)\r\n\r\n    # Set rendering quality settings\r\n    carb.settings.get_settings().set("/rtx-defaults/quality", 4)  # Maximum quality\r\n    carb.settings.get_settings().set("/rtx-defaults/resolution/width", 1920)\r\n    carb.settings.get_settings().set("/rtx-defaults/resolution/height", 1080)\n'})}),"\n",(0,t.jsx)(r.h2,{id:"best-practices-for-photorealistic-simulation",children:"Best Practices for Photorealistic Simulation"}),"\n",(0,t.jsx)(r.h3,{id:"scene-optimization",children:"Scene Optimization"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Use Proxy Geometries"}),": For distant objects, use simplified representations"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Level of Detail"}),": Implement LOD systems for geometry and physics"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Texture Streaming"}),": Load textures on-demand based on visibility"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Occlusion Culling"}),": Don't render objects not visible to cameras"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"material-best-practices",children:"Material Best Practices"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Physically Accurate Values"}),": Use real-world material properties"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Consistent Units"}),": Maintain consistent measurement units throughout"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Realistic Lighting"}),": Match real-world lighting conditions"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Validation"}),": Compare rendered images to real photos when possible"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"sensor-simulation-accuracy",children:"Sensor Simulation Accuracy"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Calibration"}),": Simulate sensor calibration parameters"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Noise Models"}),": Include realistic noise characteristics"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Distortion"}),": Simulate lens distortion for cameras"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Temporal Effects"}),": Include motion blur and rolling shutter effects"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Install Isaac Sim and set up a basic simulation environment"}),"\n",(0,t.jsx)(r.li,{children:"Create a simple humanoid robot model using USD prims"}),"\n",(0,t.jsx)(r.li,{children:"Implement photorealistic rendering with proper lighting"}),"\n",(0,t.jsx)(r.li,{children:"Add high-fidelity sensors (camera, LiDAR) to the robot"}),"\n",(0,t.jsx)(r.li,{children:"Optimize the simulation for real-time performance"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(r.p,{children:"Isaac Sim provides state-of-the-art photorealistic simulation capabilities essential for modern humanoid robotics development. By leveraging Omniverse's rendering pipeline, PhysX physics, and advanced sensor simulation, you can create highly realistic virtual environments for robot development and AI training. Proper optimization and material setup are crucial for achieving both visual quality and performance. In the next chapter, we'll explore synthetic data generation for AI model training."}),"\n",(0,t.jsx)(r.h2,{id:"learning-path-adjustment",children:"Learning Path Adjustment"}),"\n",(0,t.jsx)(r.p,{children:"Based on your experience level, you may want to focus on:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Beginner"}),": Focus on basic Isaac Sim setup and simple scene creation"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Intermediate"}),": Dive deeper into material creation and sensor integration"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Advanced"}),": Explore GPU optimization and large-scale environment creation"]}),"\n"]})]})}function m(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>o});var i=n(6540);const t={},a=i.createContext(t);function s(e){const r=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(a.Provider,{value:r},e.children)}}}]);