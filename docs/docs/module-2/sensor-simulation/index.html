<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-module-2/sensor-simulation" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">Sensor Simulation: LiDAR, Depth Camera, IMU | Agentic Sphere - Physical AI &amp; Humanoid Robotics</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://Mrsaleem110.github.io/Physical-AI-humanoid-robotic-chatbot-book/img/logo.svg"><meta data-rh="true" name="twitter:image" content="https://Mrsaleem110.github.io/Physical-AI-humanoid-robotic-chatbot-book/img/logo.svg"><meta data-rh="true" property="og:url" content="https://Mrsaleem110.github.io/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/sensor-simulation/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" property="og:locale:alternate" content="ur"><meta data-rh="true" property="og:locale:alternate" content="ko"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Sensor Simulation: LiDAR, Depth Camera, IMU | Agentic Sphere - Physical AI &amp; Humanoid Robotics"><meta data-rh="true" name="description" content="Chapter Objectives"><meta data-rh="true" property="og:description" content="Chapter Objectives"><link data-rh="true" rel="icon" href="/Physical-AI-humanoid-robotic-chatbot-book/img/logo.svg"><link data-rh="true" rel="canonical" href="https://Mrsaleem110.github.io/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/sensor-simulation/"><link data-rh="true" rel="alternate" href="https://Mrsaleem110.github.io/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/sensor-simulation/" hreflang="en"><link data-rh="true" rel="alternate" href="https://Mrsaleem110.github.io/Physical-AI-humanoid-robotic-chatbot-book/ur/docs/module-2/sensor-simulation/" hreflang="ur"><link data-rh="true" rel="alternate" href="https://Mrsaleem110.github.io/Physical-AI-humanoid-robotic-chatbot-book/ko/docs/module-2/sensor-simulation/" hreflang="ko"><link data-rh="true" rel="alternate" href="https://Mrsaleem110.github.io/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/sensor-simulation/" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Sensor Simulation: LiDAR, Depth Camera, IMU","item":"https://Mrsaleem110.github.io/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/sensor-simulation"}]}</script><script src="/Physical-AI-humanoid-robotic-chatbot-book/js/translate-button.js" async></script>
<script src="/Physical-AI-humanoid-robotic-chatbot-book/js/controlled-translation.js" async></script><link rel="stylesheet" href="/Physical-AI-humanoid-robotic-chatbot-book/assets/css/styles.4f973bb5.css">
<script src="/Physical-AI-humanoid-robotic-chatbot-book/assets/js/runtime~main.339ad965.js" defer="defer"></script>
<script src="/Physical-AI-humanoid-robotic-chatbot-book/assets/js/main.81796773.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Physical-AI-humanoid-robotic-chatbot-book/"><div class="navbar__logo"><img src="/Physical-AI-humanoid-robotic-chatbot-book/img/logo.svg" alt="Agentic Sphere Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/Physical-AI-humanoid-robotic-chatbot-book/img/logo.svg" alt="Agentic Sphere Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Agentic Sphere</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/intro/">Book</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="navbar__item"><div id="translate-button-mount" style="display: flex; align-items: center;"></div></div><a class="navbar__item navbar__link" href="/Physical-AI-humanoid-robotic-chatbot-book/auth/">Sign In</a><a href="https://github.com/Mrsaleem110/Physical-AI-humanoid-robotic-chatbot-book" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/intro/"><span title="Introduction" class="categoryLinkLabel_W154">Introduction</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/intro/"><span title="Introduction" class="linkLabel_WmDU">Introduction</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/getting-started/"><span title="getting-started" class="linkLabel_WmDU">getting-started</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/interactive-features/"><span title="Interactive Features" class="linkLabel_WmDU">Interactive Features</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-1/intro-to-ros2/"><span title="Module 1: The Robotic Nervous System (ROS 2)" class="categoryLinkLabel_W154">Module 1: The Robotic Nervous System (ROS 2)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-1/intro-to-ros2/"><span title="Introduction to ROS 2" class="linkLabel_WmDU">Introduction to ROS 2</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-1/ros2-nodes-topics-services/"><span title="ROS 2 Nodes, Topics, and Services" class="linkLabel_WmDU">ROS 2 Nodes, Topics, and Services</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-1/python-ros-control/"><span title="Python → ROS Control via rclpy" class="linkLabel_WmDU">Python → ROS Control via rclpy</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-1/urdf-humanoid-robots/"><span title="URDF for Humanoid Robots" class="linkLabel_WmDU">URDF for Humanoid Robots</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/physics-simulation-fundamentals/"><span title="Module 2: The Digital Twin (Gazebo &amp; Unity)" class="categoryLinkLabel_W154">Module 2: The Digital Twin (Gazebo &amp; Unity)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/physics-simulation-fundamentals/"><span title="Physics Simulation Fundamentals" class="linkLabel_WmDU">Physics Simulation Fundamentals</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/gravity-collision-modeling/"><span title="Gravity, Collision, and Environment Modeling" class="linkLabel_WmDU">Gravity, Collision, and Environment Modeling</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/unity-hri-visualization/"><span title="Unity-Based HRI Visualization" class="linkLabel_WmDU">Unity-Based HRI Visualization</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/sensor-simulation/"><span title="Sensor Simulation: LiDAR, Depth Camera, IMU" class="linkLabel_WmDU">Sensor Simulation: LiDAR, Depth Camera, IMU</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-3/isaac-sim-photorealistic/"><span title="Module 3: The AI-Robot Brain (NVIDIA Isaac)" class="categoryLinkLabel_W154">Module 3: The AI-Robot Brain (NVIDIA Isaac)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-3/isaac-sim-photorealistic/"><span title="Isaac Sim Photorealistic Simulation" class="linkLabel_WmDU">Isaac Sim Photorealistic Simulation</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-3/synthetic-data-generation/"><span title="Isaac Sim Synthetic Data Generation" class="linkLabel_WmDU">Isaac Sim Synthetic Data Generation</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-3/isaac-ros-vslam-perception/"><span title="Isaac ROS Accelerated VSLAM and Perception" class="linkLabel_WmDU">Isaac ROS Accelerated VSLAM and Perception</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-3/nav2-humanoid-locomotion/"><span title="Nav2 for Humanoid Locomotion and Path Planning" class="linkLabel_WmDU">Nav2 for Humanoid Locomotion and Path Planning</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-4/whisper-voice-intent/"><span title="Module 4: Vision-Language-Action (VLA)" class="categoryLinkLabel_W154">Module 4: Vision-Language-Action (VLA)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-4/whisper-voice-intent/"><span title="Whisper Voice-to-Intent Pipeline" class="linkLabel_WmDU">Whisper Voice-to-Intent Pipeline</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-4/llm-cognitive-planning/"><span title="LLM-based Cognitive Planning (NL → ROS 2 Actions)" class="linkLabel_WmDU">LLM-based Cognitive Planning (NL → ROS 2 Actions)</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-4/object-detection-manipulation/"><span title="Object Detection + Manipulation Pipeline" class="linkLabel_WmDU">Object Detection + Manipulation Pipeline</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-4/capstone-autonomous-humanoid/"><span title="Capstone: Autonomous Humanoid Control System" class="linkLabel_WmDU">Capstone: Autonomous Humanoid Control System</span></a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/Physical-AI-humanoid-robotic-chatbot-book/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Module 2: The Digital Twin (Gazebo &amp; Unity)</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Sensor Simulation: LiDAR, Depth Camera, IMU</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Sensor Simulation: LiDAR, Depth Camera, IMU</h1></header>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="chapter-objectives">Chapter Objectives<a href="#chapter-objectives" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<ul>
<li class="">Implement realistic LiDAR sensor simulation</li>
<li class="">Create depth camera simulation with realistic noise models</li>
<li class="">Simulate IMU sensors with drift and noise characteristics</li>
<li class="">Integrate sensor data with ROS/ROS 2 for robotics applications</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="introduction-to-sensor-simulation">Introduction to Sensor Simulation<a href="#introduction-to-sensor-simulation" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<p>Sensor simulation is crucial for humanoid robotics development as it:</p>
<ul>
<li class="">Provides realistic sensor data for algorithm development</li>
<li class="">Enables testing without physical sensors</li>
<li class="">Allows simulation of sensor failures and edge cases</li>
<li class="">Supports AI training with synthetic data</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="sensor-categories-for-humanoid-robots">Sensor Categories for Humanoid Robots<a href="#sensor-categories-for-humanoid-robots" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<p>Humanoid robots typically use several sensor types:</p>
<ol>
<li class=""><strong>LiDAR</strong>: 360-degree distance measurements for mapping and navigation</li>
<li class=""><strong>Depth Cameras</strong>: 3D point clouds for object recognition and manipulation</li>
<li class=""><strong>IMU</strong>: Inertial measurements for orientation and motion</li>
<li class=""><strong>Other Sensors</strong>: GPS, force/torque, tactile, etc.</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="lidar-simulation">LiDAR Simulation<a href="#lidar-simulation" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="lidar-physics-and-characteristics">LiDAR Physics and Characteristics<a href="#lidar-physics-and-characteristics" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<p>LiDAR (Light Detection and Ranging) sensors emit laser pulses and measure the time of flight to determine distances. Key characteristics include:</p>
<ul>
<li class=""><strong>Range</strong>: Maximum distance measurement (typically 5-100m)</li>
<li class=""><strong>Resolution</strong>: Angular resolution (typically 0.1°-1°)</li>
<li class=""><strong>Field of View</strong>: Horizontal and vertical coverage</li>
<li class=""><strong>Update Rate</strong>: How frequently measurements are taken</li>
<li class=""><strong>Accuracy</strong>: Measurement precision and noise characteristics</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="lidar-simulation-in-gazebo">LiDAR Simulation in Gazebo<a href="#lidar-simulation-in-gazebo" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<div class="language-xml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-xml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">&lt;!-- URDF snippet for LiDAR sensor --&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">gazebo</span><span class="token tag" style="color:#00009f"> </span><span class="token tag attr-name" style="color:#00a4db">reference</span><span class="token tag attr-value punctuation attr-equals" style="color:#393A34">=</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag attr-value" style="color:#e3116c">lidar_link</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">sensor</span><span class="token tag" style="color:#00009f"> </span><span class="token tag attr-name" style="color:#00a4db">name</span><span class="token tag attr-value punctuation attr-equals" style="color:#393A34">=</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag attr-value" style="color:#e3116c">lidar</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag" style="color:#00009f"> </span><span class="token tag attr-name" style="color:#00a4db">type</span><span class="token tag attr-value punctuation attr-equals" style="color:#393A34">=</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag attr-value" style="color:#e3116c">ray</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">pose</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">0 0 0 0 0 0</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">pose</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">visualize</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">true</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">visualize</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">update_rate</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">10</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">update_rate</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">ray</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">scan</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">horizontal</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">samples</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">360</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">samples</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">resolution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">1</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">resolution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">min_angle</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">-3.14159</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">min_angle</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">max_angle</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">3.14159</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">max_angle</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">horizontal</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">scan</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">range</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">min</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">0.1</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">min</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">max</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">30.0</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">max</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">resolution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">0.01</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">resolution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">range</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">ray</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">plugin</span><span class="token tag" style="color:#00009f"> </span><span class="token tag attr-name" style="color:#00a4db">name</span><span class="token tag attr-value punctuation attr-equals" style="color:#393A34">=</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag attr-value" style="color:#e3116c">lidar_controller</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag" style="color:#00009f"> </span><span class="token tag attr-name" style="color:#00a4db">filename</span><span class="token tag attr-value punctuation attr-equals" style="color:#393A34">=</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag attr-value" style="color:#e3116c">libgazebo_ros_ray_sensor.so</span><span class="token tag attr-value punctuation" style="color:#393A34">&quot;</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">ros</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">namespace</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">lidar</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">namespace</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">remapping</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">~/out:=scan</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">remapping</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">ros</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">output_type</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">sensor_msgs/LaserScan</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">output_type</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">plugin</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">sensor</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">gazebo</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="lidar-simulation-in-unity">LiDAR Simulation in Unity<a href="#lidar-simulation-in-unity" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Scripts/LiDARSimulator.cs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections.Generic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class LiDARSimulator : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;LiDAR Configuration&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int beamCount = 360;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float minAngle = -Mathf.PI;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float maxAngle = Mathf.PI;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float maxRange = 30f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float updateRate = 10f; // Hz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LayerMask detectionLayers = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Noise Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float noiseStdDev = 0.01f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float biasError = 0f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Visualization&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool visualizeBeams = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LineRenderer lineRenderer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float[] ranges;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float updateInterval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float lastUpdate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ranges = new float[beamCount];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateInterval = 1f / updateRate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastUpdate = -updateInterval; // Allow immediate first update</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (lineRenderer == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lineRenderer = GetComponent&lt;LineRenderer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (lineRenderer == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lineRenderer = gameObject.AddComponent&lt;LineRenderer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lineRenderer.material = new Material(Shader.Find(&quot;Sprites/Default&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lineRenderer.startWidth = 0.01f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lineRenderer.endWidth = 0.01f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lineRenderer.positionCount = beamCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Update()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Time.time - lastUpdate &gt;= updateInterval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SimulateLiDAR();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lastUpdate = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void SimulateLiDAR()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; beamCount; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float angle = Mathf.Lerp(minAngle, maxAngle, (float)i / (beamCount - 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 direction = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Perform raycast</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RaycastHit hit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Physics.Raycast(transform.position, transform.TransformDirection(direction), out hit, maxRange, detectionLayers))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float distance = hit.distance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Add noise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float noisyDistance = AddNoise(distance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ranges[i] = noisyDistance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ranges[i] = float.MaxValue; // No hit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (visualizeBeams)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            UpdateVisualization();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Publish simulated data (in a real implementation, this would publish to ROS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PublishLiDARData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float AddNoise(float trueValue)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add Gaussian noise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float noise = RandomGaussian() * noiseStdDev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return trueValue + noise + biasError;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float RandomGaussian()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Box-Muller transform for Gaussian random numbers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u1 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u2 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Mathf.Sqrt(-2f * Mathf.Log(u1)) * Mathf.Cos(2f * Mathf.PI * u2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void UpdateVisualization()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3[] positions = new Vector3[beamCount];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; beamCount; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float angle = Mathf.Lerp(minAngle, maxAngle, (float)i / (beamCount - 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 direction = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ranges[i] &lt; maxRange)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                positions[i] = transform.position + transform.TransformDirection(direction) * ranges[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                positions[i] = transform.position + transform.TransformDirection(direction) * maxRange * 0.9f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lineRenderer.SetPositions(positions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PublishLiDARData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // In a real implementation, this would publish to ROS/ROS 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // For now, we&#x27;ll just log the data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Debug.Log($&quot;LiDAR: {beamCount} beams, first range: {ranges[0]:F3}m&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float[] GetRanges()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ranges;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float GetRange(int beamIndex)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (beamIndex &gt;= 0 &amp;&amp; beamIndex &lt; ranges.Length)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ranges[beamIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return float.MaxValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="depth-camera-simulation">Depth Camera Simulation<a href="#depth-camera-simulation" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="depth-camera-characteristics">Depth Camera Characteristics<a href="#depth-camera-characteristics" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<p>Depth cameras provide 3D point cloud data by measuring distance to objects in the scene. Key characteristics include:</p>
<ul>
<li class=""><strong>Resolution</strong>: Image dimensions (e.g., 640x480, 1280x720)</li>
<li class=""><strong>Field of View</strong>: Horizontal and vertical angles</li>
<li class=""><strong>Depth Range</strong>: Minimum and maximum measurable distances</li>
<li class=""><strong>Accuracy</strong>: Distance measurement precision</li>
<li class=""><strong>Frame Rate</strong>: How often images are captured</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="depth-camera-simulation-in-unity">Depth Camera Simulation in Unity<a href="#depth-camera-simulation-in-unity" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Scripts/DepthCameraSimulator.cs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DepthCameraSimulator : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Camera Configuration&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int width = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int height = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float fieldOfView = 60f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float nearClip = 0.1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float farClip = 10f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Noise Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float noiseStdDev = 0.02f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float biasError = 0f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float depthScale = 1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Output Settings&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool outputPointCloud = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool outputDepthImage = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Camera depthCamera;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private RenderTexture depthTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float[,] depthData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private GameObject pointCloudObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SetupCamera();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CreateDepthTexture();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthData = new float[width, height];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void SetupCamera()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera = GetComponent&lt;Camera&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (depthCamera == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            depthCamera = gameObject.AddComponent&lt;Camera&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.fieldOfView = fieldOfView;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.nearClipPlane = nearClip;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.farClipPlane = farClip;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.depth = -1; // Render after other cameras</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.clearFlags = CameraClearFlags.SolidColor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.backgroundColor = Color.white;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.enabled = false; // We&#x27;ll render manually</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void CreateDepthTexture()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTexture = new RenderTexture(width, height, 24, RenderTextureFormat.Depth);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTexture.Create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.targetTexture = depthTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Update()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SimulateDepthCamera();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void SimulateDepthCamera()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Render the scene from this camera&#x27;s perspective</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthCamera.Render();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Read depth data from render texture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReadDepthData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add noise to simulate real sensor characteristics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        AddNoiseToDepthData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (outputPointCloud)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            GeneratePointCloud();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (outputDepthImage)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            OutputDepthImage();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void ReadDepthData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Create a temporary render texture to read the depth data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture currentRT = RenderTexture.active;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = depthTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Texture2D depthTex = new Texture2D(width, height, TextureFormat.RFloat, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTex.ReadPixels(new Rect(0, 0, width, height), 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTex.Apply();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert texture data to depth values</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Color[] pixels = depthTex.GetPixels();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int y = 0; y &lt; height; y++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int x = 0; x &lt; width; x++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int index = y * width + x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float rawDepth = pixels[index].r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Convert raw depth to actual distance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // This is a simplified conversion - real implementation would be more complex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float actualDepth = ConvertRawDepthToDistance(rawDepth);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                depthData[x, y] = actualDepth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Clean up</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = currentRT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DestroyImmediate(depthTex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float ConvertRawDepthToDistance(float rawDepth)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert raw depth buffer value to actual distance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This is a simplified conversion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float zNear = depthCamera.nearClipPlane;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float zFar = depthCamera.farClipPlane;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert from [0,1] to actual distance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float linearDepth = (2.0f * zNear * zFar) / (zFar + zNear - rawDepth * (zFar - zNear));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return linearDepth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void AddNoiseToDepthData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int y = 0; y &lt; height; y++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int x = 0; x &lt; width; x++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (depthData[x, y] &lt; farClip) // Only add noise to valid measurements</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float noise = RandomGaussian() * noiseStdDev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    depthData[x, y] += noise + biasError;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Ensure depth is within valid range</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    depthData[x, y] = Mathf.Clamp(depthData[x, y], nearClip, farClip);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float RandomGaussian()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Box-Muller transform for Gaussian random numbers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u1 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u2 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Mathf.Sqrt(-2f * Mathf.Log(u1)) * Mathf.Cos(2f * Mathf.PI * u2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void GeneratePointCloud()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Generate point cloud from depth data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3[] points = new Vector3[width * height];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int pointCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float fovX = fieldOfView * Mathf.Deg2Rad;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float fovY = (fieldOfView * height / width) * Mathf.Deg2Rad;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int y = 0; y &lt; height; y++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int x = 0; x &lt; width; x++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float depth = depthData[x, y];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (depth &gt; 0 &amp;&amp; depth &lt; farClip) // Valid depth measurement</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Convert pixel coordinates to 3D coordinates</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float u = (float)x / width - 0.5f; // -0.5 to 0.5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float v = (float)y / height - 0.5f; // -0.5 to 0.5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float x3d = u * depth * Mathf.Tan(fovX / 2) * 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float y3d = -v * depth * Mathf.Tan(fovY / 2) * 2; // Negative because screen coordinates are inverted</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float z3d = depth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Vector3 point = transform.TransformPoint(new Vector3(x3d, y3d, z3d));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    points[pointCount] = point;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    pointCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Resize array to actual point count</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.Array.Resize(ref points, pointCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // In a real implementation, you would publish this point cloud to ROS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Debug.Log($&quot;Generated point cloud with {pointCount} points&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void OutputDepthImage()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Create a texture to visualize the depth data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Texture2D depthVisualization = new Texture2D(width, height, TextureFormat.RGB24, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int y = 0; y &lt; height; y++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int x = 0; x &lt; width; x++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float depth = depthData[x, y];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Normalize depth for visualization (0 = near, 1 = far)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float normalizedDepth = Mathf.InverseLerp(nearClip, farClip, depth);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Map to grayscale color</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Color color = Color.Lerp(Color.white, Color.black, normalizedDepth);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                depthVisualization.SetPixel(x, y, color);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthVisualization.Apply();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // In a real implementation, you would publish this image to ROS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float[,] GetDepthData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return depthData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float GetDepthAt(int x, int y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return depthData[x, y];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return float.MaxValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="imu-simulation">IMU Simulation<a href="#imu-simulation" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="imu-characteristics">IMU Characteristics<a href="#imu-characteristics" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<p>An IMU (Inertial Measurement Unit) typically combines:</p>
<ul>
<li class=""><strong>Accelerometer</strong>: Measures linear acceleration</li>
<li class=""><strong>Gyroscope</strong>: Measures angular velocity</li>
<li class=""><strong>Magnetometer</strong>: Measures magnetic field (for heading)</li>
</ul>
<p>Key characteristics include:</p>
<ul>
<li class=""><strong>Bias</strong>: Systematic offset in measurements</li>
<li class=""><strong>Noise</strong>: Random fluctuations in measurements</li>
<li class=""><strong>Drift</strong>: Slow accumulation of errors over time</li>
<li class=""><strong>Scale Factor Error</strong>: Mismatch between input and output</li>
<li class=""><strong>Cross-Axis Sensitivity</strong>: Sensitivity to inputs in other axes</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="imu-simulation-implementation">IMU Simulation Implementation<a href="#imu-simulation-implementation" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Scripts/IMUSimulator.cs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[System.Serializable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public struct IMUReading</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 linearAcceleration;  // m/s^2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 angularVelocity;     // rad/s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 magneticField;       // Tesla</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 orientation;         // Euler angles in radians</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public double timestamp;            // Simulation time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class IMUSimulator : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Accelerometer Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float accelerometerNoiseDensity = 8.75e-4f; // m/s^2 / sqrt(Hz)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float accelerometerRandomWalk = 2.92e-5f;   // m/s^3 / sqrt(Hz)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 accelerometerBias = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float accelerometerScaleFactorError = 0.001f; // 0.1%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Gyroscope Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float gyroscopeNoiseDensity = 1.64e-4f; // rad/s / sqrt(Hz)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float gyroscopeRandomWalk = 5.42e-6f;   // rad/s^2 / sqrt(Hz)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 gyroscopeBias = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float gyroscopeScaleFactorError = 0.001f; // 0.1%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Magnetometer Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float magnetometerNoise = 0.05e-6f; // Tesla</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 magnetometerBias = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Simulation Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float updateRate = 100f; // Hz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool enableDrift = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private IMUReading currentReading;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float updateInterval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float lastUpdate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Bias drift accumulators</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 accelerometerBiasDrift = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 gyroscopeBiasDrift = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateInterval = 1f / updateRate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastUpdate = -updateInterval; // Allow immediate first update</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Initialize with current transform values</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UpdateIMUReading();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Update()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Time.time - lastUpdate &gt;= updateInterval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            UpdateIMUReading();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lastUpdate = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void UpdateIMUReading()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Get true values from Unity&#x27;s physics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 trueLinearAcceleration = GetTrueLinearAcceleration();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 trueAngularVelocity = GetTrueAngularVelocity();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 trueMagneticField = GetTrueMagneticField();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 trueOrientation = transform.eulerAngles * Mathf.Deg2Rad;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add noise and errors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        currentReading.linearAcceleration = AddAccelerometerNoise(trueLinearAcceleration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        currentReading.angularVelocity = AddGyroscopeNoise(trueAngularVelocity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        currentReading.magneticField = AddMagnetometerNoise(trueMagneticField);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        currentReading.orientation = trueOrientation; // Add noise to orientation if needed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        currentReading.timestamp = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Publish simulated data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PublishIMUData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 GetTrueLinearAcceleration()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Calculate true linear acceleration from Unity physics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This is a simplified approach - in practice, you&#x27;d need to account for gravity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Rigidbody rb = GetComponent&lt;Rigidbody&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rb != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Remove gravity from the acceleration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return rb.velocity - Physics.gravity * Time.deltaTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // If no rigidbody, use transform changes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return (transform.position - transform.position) / (Time.deltaTime * Time.deltaTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 GetTrueAngularVelocity()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Calculate true angular velocity from Unity physics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Rigidbody rb = GetComponent&lt;Rigidbody&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rb != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return rb.angularVelocity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // If no rigidbody, approximate from rotation change</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Vector3.zero; // Simplified - would need to track rotation over time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 GetTrueMagneticField()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Return a typical Earth magnetic field vector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This should be adjusted based on geographic location</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Vector3(0.22f, 0.0f, 0.45f) * 1e-6f; // Tesla</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 AddAccelerometerNoise(Vector3 trueAcceleration)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 noise = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * accelerometerNoiseDensity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * accelerometerNoiseDensity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * accelerometerNoiseDensity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add bias (with drift if enabled)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 bias = accelerometerBias + accelerometerBiasDrift;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add scale factor error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 scaledAcceleration = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trueAcceleration.x * (1 + accelerometerScaleFactorError),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trueAcceleration.y * (1 + accelerometerScaleFactorError),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trueAcceleration.z * (1 + accelerometerScaleFactorError)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add random walk to bias</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enableDrift)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            accelerometerBiasDrift += new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RandomGaussian() * accelerometerRandomWalk * Mathf.Sqrt(updateInterval),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RandomGaussian() * accelerometerRandomWalk * Mathf.Sqrt(updateInterval),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RandomGaussian() * accelerometerRandomWalk * Mathf.Sqrt(updateInterval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return scaledAcceleration + noise + bias;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 AddGyroscopeNoise(Vector3 trueAngularVelocity)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 noise = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * gyroscopeNoiseDensity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * gyroscopeNoiseDensity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * gyroscopeNoiseDensity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add bias (with drift if enabled)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 bias = gyroscopeBias + gyroscopeBiasDrift;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add scale factor error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 scaledAngularVelocity = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trueAngularVelocity.x * (1 + gyroscopeScaleFactorError),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trueAngularVelocity.y * (1 + gyroscopeScaleFactorError),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trueAngularVelocity.z * (1 + gyroscopeScaleFactorError)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add random walk to bias</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enableDrift)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gyroscopeBiasDrift += new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RandomGaussian() * gyroscopeRandomWalk * Mathf.Sqrt(updateInterval),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RandomGaussian() * gyroscopeRandomWalk * Mathf.Sqrt(updateInterval),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RandomGaussian() * gyroscopeRandomWalk * Mathf.Sqrt(updateInterval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return scaledAngularVelocity + noise + bias;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vector3 AddMagnetometerNoise(Vector3 trueMagneticField)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 noise = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * magnetometerNoise,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * magnetometerNoise,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RandomGaussian() * magnetometerNoise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add bias</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 bias = magnetometerBias;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return trueMagneticField + noise + bias;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float RandomGaussian()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Box-Muller transform for Gaussian random numbers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u1 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float u2 = Random.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Mathf.Sqrt(-2f * Mathf.Log(u1)) * Mathf.Cos(2f * Mathf.PI * u2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PublishIMUData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // In a real implementation, this would publish to ROS/ROS 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Debug.Log($&quot;IMU: Acc=({currentReading.linearAcceleration.x:F3}, {currentReading.linearAcceleration.y:F3}, {currentReading.linearAcceleration.z:F3})&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public IMUReading GetIMUReading()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return currentReading;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void ResetBiasDrift()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        accelerometerBiasDrift = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gyroscopeBiasDrift = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="sensor-fusion-and-integration">Sensor Fusion and Integration<a href="#sensor-fusion-and-integration" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="multi-sensor-data-integration">Multi-Sensor Data Integration<a href="#multi-sensor-data-integration" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Scripts/SensorFusion.cs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections.Generic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SensorFusion : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Sensor References&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LiDARSimulator lidar;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DepthCameraSimulator depthCamera;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public IMUSimulator imu;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Fusion Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float lidarWeight = 0.4f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float depthWeight = 0.3f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float imuWeight = 0.3f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Queue&lt;IMUReading&gt; imuBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float bufferDuration = 1.0f; // seconds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuBuffer = new Queue&lt;IMUReading&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Update()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Integrate sensor data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ProcessSensorData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void ProcessSensorData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Get current readings from all sensors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float[] lidarData = lidar != null ? lidar.GetRanges() : new float[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float[,] depthData = depthCamera != null ? depthCamera.GetDepthData() : new float[0, 0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IMUReading imuData = imu != null ? imu.GetIMUReading() : new IMUReading();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Store IMU data in buffer for temporal fusion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (imu != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            imuBuffer.Enqueue(imuData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Remove old data from buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (imuBuffer.Count &gt; 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   Time.time - imuBuffer.Peek().timestamp &gt; bufferDuration)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                imuBuffer.Dequeue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Perform sensor fusion (simplified example)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PerformFusion(lidarData, depthData, imuData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PerformFusion(float[] lidarData, float[,] depthData, IMUReading imuData)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Example fusion algorithm: combine position estimates</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 positionEstimate = Vector3.zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Calculate position from IMU integration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (imuBuffer.Count &gt; 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            IMUReading first = imuBuffer.Peek();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            IMUReading last = imuBuffer.ToArray()[imuBuffer.Count - 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float deltaTime = (float)(last.timestamp - first.timestamp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (deltaTime &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Vector3 velocity = (last.linearAcceleration + first.linearAcceleration) * 0.5f * deltaTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                positionEstimate += velocity * imuWeight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // In a real implementation, you would combine this with LiDAR and depth data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // for more accurate position estimation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Debug.Log($&quot;Fused position estimate: {positionEstimate}&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 GetFusedPositionEstimate()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Return the fused position estimate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return transform.position; // Simplified</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="best-practices-for-sensor-simulation">Best Practices for Sensor Simulation<a href="#best-practices-for-sensor-simulation" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="realistic-noise-modeling">Realistic Noise Modeling<a href="#realistic-noise-modeling" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<ul>
<li class=""><strong>Characterize Real Sensors</strong>: Understand the noise characteristics of your actual sensors</li>
<li class=""><strong>Include Bias and Drift</strong>: Model systematic errors that accumulate over time</li>
<li class=""><strong>Validate Against Reality</strong>: Compare simulated and real sensor data</li>
<li class=""><strong>Temperature Effects</strong>: Consider how temperature affects sensor performance</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="performance-optimization">Performance Optimization<a href="#performance-optimization" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<ul>
<li class=""><strong>Efficient Raycasting</strong>: Use optimized algorithms for LiDAR simulation</li>
<li class=""><strong>Level of Detail</strong>: Reduce sensor resolution when performance is critical</li>
<li class=""><strong>Parallel Processing</strong>: Use multi-threading for sensor simulation</li>
<li class=""><strong>Caching</strong>: Cache results when possible for repeated queries</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="validation-and-testing">Validation and Testing<a href="#validation-and-testing" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<ul>
<li class=""><strong>Ground Truth Comparison</strong>: Compare simulated data to known ground truth</li>
<li class=""><strong>Edge Case Testing</strong>: Test with challenging scenarios (bright light, occlusions, etc.)</li>
<li class=""><strong>Cross-Sensor Validation</strong>: Verify consistency between different sensor modalities</li>
<li class=""><strong>Temporal Consistency</strong>: Ensure sensor data is consistent over time</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="integration-with-rosros-2">Integration with ROS/ROS 2<a href="#integration-with-rosros-2" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="ros-message-publishing">ROS Message Publishing<a href="#ros-message-publishing" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h3>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Scripts/ROSPublisher.cs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using Unity.Robotics.ROSTCPConnector;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using RosMessageTypes.Sensor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using RosMessageTypes.Geometry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ROSPublisher : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ROSConnection ros;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Topic Names&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string laserScanTopic = &quot;scan&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string pointCloudTopic = &quot;point_cloud&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string imuTopic = &quot;imu/data&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Sensors&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LiDARSimulator lidar;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DepthCameraSimulator depthCamera;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public IMUSimulator imu;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ros = ROSConnection.instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Update()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PublishSensorData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PublishSensorData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (lidar != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            PublishLaserScan();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (depthCamera != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            PublishPointCloud();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (imu != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            PublishIMU();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PublishLaserScan()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        var scanMsg = new sensor_msgs.LaserScanMsg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanMsg.header = new std_msgs.HeaderMsg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanMsg.header.stamp = new builtin_interfaces.TimeMsg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanMsg.header.frame_id = &quot;lidar_frame&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float[] ranges = lidar.GetRanges();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanMsg.ranges = new float[ranges.Length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; ranges.Length; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            scanMsg.ranges[i] = ranges[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanMsg.angle_min = lidar.minAngle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanMsg.angle_max = lidar.maxAngle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanMsg.angle_increment = (lidar.maxAngle - lidar.minAngle) / (ranges.Length - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanMsg.range_min = 0.1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanMsg.range_max = lidar.maxRange;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ros.Publish(laserScanTopic, scanMsg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PublishPointCloud()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Publish point cloud from depth camera</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Implementation would convert depth data to PointCloud2 message</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PublishIMU()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IMUReading reading = imu.GetIMUReading();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        var imuMsg = new sensor_msgs.ImuMsg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.header = new std_msgs.HeaderMsg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.header.stamp = new builtin_interfaces.TimeMsg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.header.frame_id = &quot;imu_frame&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert to ROS message format</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.linear_acceleration.x = reading.linearAcceleration.x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.linear_acceleration.y = reading.linearAcceleration.y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.linear_acceleration.z = reading.linearAcceleration.z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.angular_velocity.x = reading.angularVelocity.x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.angular_velocity.y = reading.angularVelocity.y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.angular_velocity.z = reading.angularVelocity.z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert Euler angles to quaternion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuMsg.orientation = Unity.Robotics.ROSTCPConnector.MessageExtensions.To&lt;geometry_msgs.QuaternionMsg&gt;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Quaternion.Euler(reading.orientation * Mathf.Rad2Deg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ros.Publish(imuTopic, imuMsg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="hands-on-exercise">Hands-On Exercise<a href="#hands-on-exercise" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<ol>
<li class="">Implement a LiDAR sensor simulation with realistic noise characteristics</li>
<li class="">Create a depth camera simulator with point cloud generation</li>
<li class="">Develop an IMU simulator with bias drift and random walk</li>
<li class="">Integrate all sensors with ROS/ROS 2 message publishing</li>
<li class="">Validate sensor data against expected real-world behavior</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="summary">Summary<a href="#summary" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<p>Sensor simulation is fundamental to humanoid robotics development, providing realistic data for algorithm development and testing. By accurately modeling sensor characteristics including noise, bias, and drift, you can create effective simulation environments that closely match real-world conditions. Proper integration with ROS/ROS 2 enables seamless transition from simulation to real hardware. In the next module, we&#x27;ll explore NVIDIA Isaac Sim for photorealistic simulation and synthetic data generation.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="learning-path-adjustment">Learning Path Adjustment<a href="#learning-path-adjustment" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading" translate="no">​</a></h2>
<p>Based on your experience level, you may want to focus on:</p>
<ul>
<li class=""><strong>Beginner</strong>: Focus on basic sensor simulation and visualization</li>
<li class=""><strong>Intermediate</strong>: Dive deeper into noise modeling and sensor fusion</li>
<li class=""><strong>Advanced</strong>: Explore advanced sensor physics and AI training applications</li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/Mrsaleem110/Physical-AI-humanoid-robotic-chatbot-book/tree/main/docs/docs/module-2/sensor-simulation.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2025-12-17T13:50:54.000Z" itemprop="dateModified">Dec 17, 2025</time></b> by <b>muhammad_saleem</b></span></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-2/unity-hri-visualization/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Unity-Based HRI Visualization</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/module-3/isaac-sim-photorealistic/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Isaac Sim Photorealistic Simulation</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#chapter-objectives" class="table-of-contents__link toc-highlight">Chapter Objectives</a></li><li><a href="#introduction-to-sensor-simulation" class="table-of-contents__link toc-highlight">Introduction to Sensor Simulation</a><ul><li><a href="#sensor-categories-for-humanoid-robots" class="table-of-contents__link toc-highlight">Sensor Categories for Humanoid Robots</a></li></ul></li><li><a href="#lidar-simulation" class="table-of-contents__link toc-highlight">LiDAR Simulation</a><ul><li><a href="#lidar-physics-and-characteristics" class="table-of-contents__link toc-highlight">LiDAR Physics and Characteristics</a></li><li><a href="#lidar-simulation-in-gazebo" class="table-of-contents__link toc-highlight">LiDAR Simulation in Gazebo</a></li><li><a href="#lidar-simulation-in-unity" class="table-of-contents__link toc-highlight">LiDAR Simulation in Unity</a></li></ul></li><li><a href="#depth-camera-simulation" class="table-of-contents__link toc-highlight">Depth Camera Simulation</a><ul><li><a href="#depth-camera-characteristics" class="table-of-contents__link toc-highlight">Depth Camera Characteristics</a></li><li><a href="#depth-camera-simulation-in-unity" class="table-of-contents__link toc-highlight">Depth Camera Simulation in Unity</a></li></ul></li><li><a href="#imu-simulation" class="table-of-contents__link toc-highlight">IMU Simulation</a><ul><li><a href="#imu-characteristics" class="table-of-contents__link toc-highlight">IMU Characteristics</a></li><li><a href="#imu-simulation-implementation" class="table-of-contents__link toc-highlight">IMU Simulation Implementation</a></li></ul></li><li><a href="#sensor-fusion-and-integration" class="table-of-contents__link toc-highlight">Sensor Fusion and Integration</a><ul><li><a href="#multi-sensor-data-integration" class="table-of-contents__link toc-highlight">Multi-Sensor Data Integration</a></li></ul></li><li><a href="#best-practices-for-sensor-simulation" class="table-of-contents__link toc-highlight">Best Practices for Sensor Simulation</a><ul><li><a href="#realistic-noise-modeling" class="table-of-contents__link toc-highlight">Realistic Noise Modeling</a></li><li><a href="#performance-optimization" class="table-of-contents__link toc-highlight">Performance Optimization</a></li><li><a href="#validation-and-testing" class="table-of-contents__link toc-highlight">Validation and Testing</a></li></ul></li><li><a href="#integration-with-rosros-2" class="table-of-contents__link toc-highlight">Integration with ROS/ROS 2</a><ul><li><a href="#ros-message-publishing" class="table-of-contents__link toc-highlight">ROS Message Publishing</a></li></ul></li><li><a href="#hands-on-exercise" class="table-of-contents__link toc-highlight">Hands-On Exercise</a></li><li><a href="#summary" class="table-of-contents__link toc-highlight">Summary</a></li><li><a href="#learning-path-adjustment" class="table-of-contents__link toc-highlight">Learning Path Adjustment</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Physical-AI-humanoid-robotic-chatbot-book/docs/intro/">Book Home</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/humanoid-robotics" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discord.com/channels/@me" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/Mrsaleem110/Physical-AI-humanoid-robotic-chatbot-book" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright @ 2025 Physical AI & Humanoid Robotics Book. Build by Agentic Sphere.</div></div></div></footer></div>
</body>
</html>