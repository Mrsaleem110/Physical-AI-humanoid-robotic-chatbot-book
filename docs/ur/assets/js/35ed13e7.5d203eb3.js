"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[428],{7911:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>_,frontMatter:()=>a,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"module-3/nav2-humanoid-locomotion","title":"nav2-humanoid-locomotion","description":"MYMEMORY WARNING//MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP TO TRANSLATE MORE","source":"@site/i18n/ur/docusaurus-plugin-content-docs/current/module-3/nav2-humanoid-locomotion.md","sourceDirName":"module-3","slug":"/module-3/nav2-humanoid-locomotion","permalink":"/Physical-AI-humanoid-robotic-chatbot-book/ur/docs/module-3/nav2-humanoid-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/Mrsaleem110/Physical-AI-humanoid-robotic-chatbot-book/tree/main/docs/docs/module-3/nav2-humanoid-locomotion.md","tags":[],"version":"current","lastUpdatedBy":"muhammad_saleem","lastUpdatedAt":1766408575000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"isaac-ros-vslam-perception","permalink":"/Physical-AI-humanoid-robotic-chatbot-book/ur/docs/module-3/isaac-ros-vslam-perception"},"next":{"title":"whisper-voice-intent","permalink":"/Physical-AI-humanoid-robotic-chatbot-book/ur/docs/module-4/whisper-voice-intent"}}');var o=n(4848),s=n(8453);const a={sidebar_position:3},i=void 0,l={},p=[];function T(r){const e={a:"a",code:"code",p:"p",pre:"pre",...(0,s.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 05 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 04 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 04 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 03 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 03 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 03 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 02 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 02 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 01 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 01 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 00 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 00 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 07 MINUTES 00 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 59 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 59 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 58 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 58 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 57 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 57 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 56 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 56 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 55 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# python/humanoid_nav2_components.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom nav_msgs.msg import Path, OccupancyGrid, Odometry\r\nfrom geometry_msgs.msg import PoseStamped, Twist\r\nfrom sensor_msgs.msg import LaserScan, PointCloud2\r\nfrom std_msgs.msg import String\r\nfrom tf2_ros import TransformListener, Buffer\r\nimport tf2_geometry_msgs\r\nimport numpy as np\r\nfrom scipy.spatial.transform import Rotation as R\r\nimport math\r\n\r\nclass HumanoidNav2Node(Node):\r\n    def __init__(self):\r\n        super().__init__(\'humanoid_nav2_node\')\r\n\r\n        # TF2 setup\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n\r\n        # Publishers and subscribers\r\n        self.global_plan_pub = self.create_publisher(Path, \'/humanoid/global_plan\', 10)\r\n        self.local_plan_pub = self.create_publisher(Path, \'/humanoid/local_plan\', 10)\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/humanoid/cmd_vel\', 10)\r\n        self.status_pub = self.create_publisher(String, \'/humanoid/nav_status\', 10)\r\n\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry,\r\n            \'/odom\',\r\n            self.odom_callback,\r\n            10\r\n        )\r\n\r\n        self.goal_sub = self.create_subscription(\r\n            PoseStamped,\r\n            \'/humanoid/goal\',\r\n            self.goal_callback,\r\n            10\r\n        )\r\n\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan,\r\n            \'/scan\',\r\n            self.scan_callback,\r\n            10\r\n        )\r\n\r\n        # Humanoid-specific state\r\n        self.current_pose = None\r\n        self.current_velocity = None\r\n        self.goal_pose = None\r\n        self.navigation_state = "IDLE"  # IDLE, PLANNING, EXECUTING, RECOVERY\r\n        self.path = []\r\n        self.current_waypoint = 0\r\n\r\n        # Humanoid locomotion parameters\r\n        self.step_length = 0.3  # meters\r\n        self.step_width = 0.2   # meters\r\n        self.step_height = 0.05 # meters (for stepping over small obstacles)\r\n        self.max_step_up = 0.1  # maximum step up height\r\n        self.max_step_down = 0.1 # maximum step down height\r\n        self.turn_angle = 0.2   # radians per step for turning\r\n\r\n        # Navigation parameters\r\n        self.linear_vel = 0.1   # m/s\r\n        self.angular_vel = 0.2  # rad/s\r\n        self.arrival_threshold = 0.2  # meters\r\n        self.yaw_threshold = 0.1      # radians\r\n\r\n        # Path planning components\r\n        self.global_planner = HumanoidGlobalPlanner()\r\n        self.local_planner = HumanoidLocalPlanner()\r\n        self.footstep_planner = FootstepPlanner()\r\n\r\n        self.get_logger().info("Humanoid Nav2 Node initialized")\r\n\r\n    def odom_callback(self, msg):\r\n        """Update current pose from odometry"""\r\n        self.current_pose = msg.pose.pose\r\n        self.current_velocity = msg.twist.twist\r\n\r\n    def goal_callback(self, msg):\r\n        """Handle new navigation goal"""\r\n        self.goal_pose = msg.pose\r\n\r\n        # Check if we have current pose\r\n        if self.current_pose is not None:\r\n            self.navigation_state = "PLANNING"\r\n            self.plan_path()\r\n\r\n    def scan_callback(self, msg):\r\n        """Process laser scan for local planning"""\r\n        if self.navigation_state == "EXECUTING":\r\n            # Update local plan based on obstacles\r\n            self.update_local_plan(msg)\r\n\r\n    def plan_path(self):\r\n        """Plan global path to goal"""\r\n        if self.current_pose is None or self.goal_pose is None:\r\n            return\r\n\r\n        # Convert poses to numpy arrays for planning\r\n        start = np.array([\r\n            self.current_pose.position.x,\r\n            self.current_pose.position.y,\r\n            self.get_yaw_from_quaternion(self.current_pose.orientation)\r\n        ])\r\n\r\n        goal = np.array([\r\n            self.goal_pose.position.x,\r\n            self.goal_pose.position.y,\r\n            self.get_yaw_from_quaternion(self.goal_pose.orientation)\r\n        ])\r\n\r\n        # Plan global path\r\n        global_path = self.global_planner.plan(start, goal)\r\n\r\n        if global_path is not None:\r\n            # Convert path to footstep plan\r\n            footstep_plan = self.footstep_planner.plan_footsteps(global_path)\r\n\r\n            # Publish global plan\r\n            self.publish_global_plan(footstep_plan)\r\n\r\n            # Start execution\r\n            self.path = footstep_plan\r\n            self.current_waypoint = 0\r\n            self.navigation_state = "EXECUTING"\r\n\r\n            # Start executing the plan\r\n            self.execute_path()\r\n\r\n    def update_local_plan(self, scan_msg):\r\n        """Update local plan based on sensor data"""\r\n        if self.navigation_state != "EXECUTING":\r\n            return\r\n\r\n        # Check for obstacles in current path\r\n        obstacles = self.process_scan_for_obstacles(scan_msg)\r\n\r\n        if self.local_planner.need_replanning(obstacles, self.path, self.current_waypoint):\r\n            self.get_logger().info("Replanning local path due to obstacles")\r\n\r\n            # Create temporary goal at current position + lookahead\r\n            current_pos = self.get_current_position()\r\n            lookahead_goal = self.get_lookahead_goal(current_pos)\r\n\r\n            local_path = self.local_planner.plan_local(\r\n                current_pos, lookahead_goal, obstacles\r\n            )\r\n\r\n            if local_path is not None:\r\n                self.path = local_path\r\n                self.current_waypoint = 0\r\n\r\n    def execute_path(self):\r\n        """Execute the planned path"""\r\n        if not self.path or self.current_waypoint >= len(self.path):\r\n            self.navigation_state = "IDLE"\r\n            self.publish_status("GOAL_REACHED")\r\n            return\r\n\r\n        # Get next waypoint\r\n        target_waypoint = self.path[self.current_waypoint]\r\n\r\n        # Calculate required motion\r\n        cmd_vel = self.calculate_motion_to_waypoint(target_waypoint)\r\n\r\n        # Check if reached waypoint\r\n        if self.is_at_waypoint(target_waypoint):\r\n            self.current_waypoint += 1\r\n            if self.current_waypoint >= len(self.path):\r\n                self.navigation_state = "IDLE"\r\n                self.publish_status("GOAL_REACHED")\r\n                return\r\n\r\n        # Publish command\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n    def calculate_motion_to_waypoint(self, waypoint):\r\n        """Calculate motion command to reach waypoint"""\r\n        cmd = Twist()\r\n\r\n        if self.current_pose is None:\r\n            return cmd\r\n\r\n        # Calculate distance and angle to waypoint\r\n        dx = waypoint[0] - self.current_pose.position.x\r\n        dy = waypoint[1] - self.current_pose.position.y\r\n        distance = math.sqrt(dx*dx + dy*dy)\r\n\r\n        # Calculate desired heading\r\n        desired_yaw = math.atan2(dy, dx)\r\n        current_yaw = self.get_yaw_from_quaternion(self.current_pose.orientation)\r\n\r\n        # Calculate angular error\r\n        angle_error = self.normalize_angle(desired_yaw - current_yaw)\r\n\r\n        # Set velocities based on errors\r\n        if distance > self.arrival_threshold:\r\n            cmd.linear.x = min(self.linear_vel, distance * 2.0)  # Proportional control\r\n        else:\r\n            cmd.linear.x = 0.0\r\n\r\n        if abs(angle_error) > self.yaw_threshold:\r\n            cmd.angular.z = max(-self.angular_vel, min(self.angular_vel, angle_error * 2.0))\r\n        else:\r\n            cmd.angular.z = 0.0\r\n\r\n        return cmd\r\n\r\n    def is_at_waypoint(self, waypoint):\r\n        """Check if robot is at the specified waypoint"""\r\n        if self.current_pose is None:\r\n            return False\r\n\r\n        dx = waypoint[0] - self.current_pose.position.x\r\n        dy = waypoint[1] - self.current_pose.position.y\r\n        distance = math.sqrt(dx*dx + dy*dy)\r\n\r\n        return distance <= self.arrival_threshold\r\n\r\n    def get_yaw_from_quaternion(self, quat):\r\n        """Extract yaw angle from quaternion"""\r\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\r\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\r\n        return math.atan2(siny_cosp, cosy_cosp)\r\n\r\n    def normalize_angle(self, angle):\r\n        """Normalize angle to [-pi, pi] range"""\r\n        while angle > math.pi:\r\n            angle -= 2.0 * math.pi\r\n        while angle < -math.pi:\r\n            angle += 2.0 * math.pi\r\n        return angle\r\n\r\n    def get_current_position(self):\r\n        """Get current position as numpy array"""\r\n        if self.current_pose is not None:\r\n            return np.array([\r\n                self.current_pose.position.x,\r\n                self.current_pose.position.y\r\n            ])\r\n        return np.array([0.0, 0.0])\r\n\r\n    def get_lookahead_goal(self, current_pos):\r\n        """Get goal position for local planning"""\r\n        if self.current_waypoint < len(self.path):\r\n            return np.array(self.path[self.current_waypoint][:2])\r\n        elif self.goal_pose is not None:\r\n            return np.array([\r\n                self.goal_pose.position.x,\r\n                self.goal_pose.position.y\r\n            ])\r\n        return current_pos\r\n\r\n    def process_scan_for_obstacles(self, scan_msg):\r\n        """Process laser scan to detect obstacles"""\r\n        obstacles = []\r\n\r\n        angle_min = scan_msg.angle_min\r\n        angle_increment = scan_msg.angle_increment\r\n\r\n        for i, range_val in enumerate(scan_msg.ranges):\r\n            if not (math.isnan(range_val) or math.isinf(range_val)) and range_val < 1.0:  # Within 1m\r\n                angle = angle_min + i * angle_increment\r\n                x = range_val * math.cos(angle)\r\n                y = range_val * math.sin(angle)\r\n                obstacles.append((x, y, range_val))\r\n\r\n        return obstacles\r\n\r\n    def publish_global_plan(self, path):\r\n        """Publish global path for visualization"""\r\n        path_msg = Path()\r\n        path_msg.header.stamp = self.get_clock().now().to_msg()\r\n        path_msg.header.frame_id = "map"\r\n\r\n        for point in path:\r\n            pose = PoseStamped()\r\n            pose.pose.position.x = point[0]\r\n            pose.pose.position.y = point[1]\r\n            pose.pose.position.z = 0.0\r\n            path_msg.poses.append(pose)\r\n\r\n        self.global_plan_pub.publish(path_msg)\r\n\r\n    def publish_status(self, status):\r\n        """Publish navigation status"""\r\n        status_msg = String()\r\n        status_msg.data = status\r\n        self.status_pub.publish(status_msg)\r\n\r\nclass HumanoidGlobalPlanner:\r\n    """Global planner adapted for humanoid robots"""\r\n    def __init__(self):\r\n        # Initialize global planner (e.g., A* or Dijkstra)\r\n        pass\r\n\r\n    def plan(self, start, goal):\r\n        """Plan global path from start to goal"""\r\n        # For humanoid robots, we might use a grid-based planner\r\n        # that considers walkable areas and step constraints\r\n        path = self.a_star_plan(start, goal)\r\n        return path\r\n\r\n    def a_star_plan(self, start, goal):\r\n        """A* path planning algorithm"""\r\n        # Simplified A* implementation\r\n        # In practice, this would be more complex and consider humanoid constraints\r\n        path = [start, goal]  # Simplified for example\r\n        return path\r\n\r\nclass HumanoidLocalPlanner:\r\n    """Local planner for humanoid robots"""\r\n    def __init__(self):\r\n        # Initialize local planner (e.g., DWA or TEB)\r\n        pass\r\n\r\n    def plan_local(self, current_pos, goal_pos, obstacles):\r\n        """Plan local path considering obstacles"""\r\n        # For humanoid robots, consider step-by-step planning\r\n        # that accounts for balance and foot placement\r\n        local_path = [current_pos, goal_pos]  # Simplified\r\n        return local_path\r\n\r\n    def need_replanning(self, obstacles, path, current_waypoint):\r\n        """Check if replanning is needed"""\r\n        # Check if obstacles block current path\r\n        for obs_x, obs_y, obs_dist in obstacles:\r\n            if obs_dist < 0.5:  # Within 50cm\r\n                return True\r\n        return False\r\n\r\nclass FootstepPlanner:\r\n    """Plan footstep sequences for humanoid navigation"""\r\n    def __init__(self):\r\n        self.step_length = 0.3\r\n        self.step_width = 0.2\r\n        self.max_turn = 0.3  # radians\r\n\r\n    def plan_footsteps(self, path):\r\n        """Convert path to footstep plan"""\r\n        footsteps = []\r\n\r\n        if len(path) < 2:\r\n            return footsteps\r\n\r\n        # Convert path to footstep sequence\r\n        # This is a simplified approach - real implementation would be more complex\r\n        for i in range(len(path) - 1):\r\n            start = path[i]\r\n            end = path[i + 1]\r\n\r\n            # Calculate intermediate footsteps\r\n            dist = math.sqrt((end[0] - start[0])**2 + (end[1] - start[1])**2)\r\n            steps_needed = max(1, int(dist / self.step_length))\r\n\r\n            for j in range(steps_needed):\r\n                ratio = j / steps_needed\r\n                x = start[0] + ratio * (end[0] - start[0])\r\n                y = start[1] + ratio * (end[1] - start[1])\r\n                theta = start[2] if len(start) > 2 else 0.0\r\n\r\n                footsteps.append([x, y, theta])\r\n\r\n        return footsteps\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    nav2_node = HumanoidNav2Node()\r\n\r\n    try:\r\n        rclpy.spin(nav2_node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        nav2_node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 55 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 55 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# python/footstep_planning.py\r\nimport numpy as np\r\nimport math\r\nfrom scipy.spatial.distance import euclidean\r\nimport matplotlib.pyplot as plt\r\n\r\nclass FootstepPlanner:\r\n    def __init__(self, step_length=0.3, step_width=0.2, step_height=0.05):\r\n        self.step_length = step_length\r\n        self.step_width = step_width\r\n        self.step_height = step_height\r\n\r\n        # Support polygon parameters\r\n        self.foot_separation = step_width\r\n        self.foot_length = 0.25\r\n        self.foot_width = 0.15\r\n\r\n    def plan_footsteps(self, start_pose, goal_pose, terrain_map=None):\r\n        """\r\n        Plan footsteps from start to goal considering terrain\r\n        start_pose: [x, y, theta]\r\n        goal_pose: [x, y, theta]\r\n        """\r\n        footsteps = []\r\n\r\n        # Calculate straight-line path\r\n        dx = goal_pose[0] - start_pose[0]\r\n        dy = goal_pose[1] - start_pose[1]\r\n        distance = math.sqrt(dx*dx + dy*dy)\r\n        goal_theta = goal_pose[2] if len(goal_pose) > 2 else 0.0\r\n\r\n        # Determine number of steps needed\r\n        num_steps = int(distance / self.step_length) + 1\r\n\r\n        # Generate footsteps along the path\r\n        for i in range(1, num_steps + 1):\r\n            ratio = i / num_steps\r\n            x = start_pose[0] + ratio * dx\r\n            y = start_pose[1] + ratio * dy\r\n            theta = start_pose[2] + ratio * (goal_theta - start_pose[2])\r\n\r\n            # Add slight variations for natural walking\r\n            step = [x, y, theta]\r\n            footsteps.append(step)\r\n\r\n        # Add final goal step\r\n        footsteps.append(goal_pose)\r\n\r\n        return footsteps\r\n\r\n    def plan_bipedal_sequence(self, footsteps):\r\n        """\r\n        Convert footsteps to alternating left/right foot sequence\r\n        """\r\n        sequence = []\r\n\r\n        if not footsteps:\r\n            return sequence\r\n\r\n        # Start with left foot\r\n        left_support = True\r\n\r\n        for i, step in enumerate(footsteps):\r\n            if left_support:\r\n                # Left foot moves, right stays in place\r\n                sequence.append({\r\n                    \'step_type\': \'left\',\r\n                    \'position\': step[:2],\r\n                    \'orientation\': step[2] if len(step) > 2 else 0.0,\r\n                    \'step_number\': i\r\n                })\r\n                left_support = False\r\n            else:\r\n                # Right foot moves, left stays in place\r\n                sequence.append({\r\n                    \'step_type\': \'right\',\r\n                    \'position\': step[:2],\r\n                    \'orientation\': step[2] if len(step) > 2 else 0.0,\r\n                    \'step_number\': i\r\n                })\r\n                left_support = True\r\n\r\n        return sequence\r\n\r\n    def check_stability(self, footsteps, com_trajectory=None):\r\n        """\r\n        Check if the footstep sequence maintains stability\r\n        """\r\n        if len(footsteps) < 2:\r\n            return True\r\n\r\n        # Calculate support polygon for each step\r\n        for i in range(len(footsteps) - 1):\r\n            left_pos = self.get_left_foot_position(footsteps[i])\r\n            right_pos = self.get_right_foot_position(footsteps[i])\r\n\r\n            # Calculate support polygon (simplified as line between feet)\r\n            support_polygon = [left_pos, right_pos]\r\n\r\n            # Check if next step is within support polygon\r\n            next_pos = footsteps[i + 1][:2]\r\n\r\n            if not self.is_in_support_polygon(next_pos, support_polygon):\r\n                return False\r\n\r\n        return True\r\n\r\n    def get_left_foot_position(self, step):\r\n        """Get left foot position based on step"""\r\n        x, y, theta = step[0], step[1], step[2]\r\n        # Offset for left foot (simplified)\r\n        offset_x = -self.foot_separation/2 * math.sin(theta)\r\n        offset_y = self.foot_separation/2 * math.cos(theta)\r\n        return [x + offset_x, y + offset_y]\r\n\r\n    def get_right_foot_position(self, step):\r\n        """Get right foot position based on step"""\r\n        x, y, theta = step[0], step[1], step[2]\r\n        # Offset for right foot (simplified)\r\n        offset_x = self.foot_separation/2 * math.sin(theta)\r\n        offset_y = -self.foot_separation/2 * math.cos(theta)\r\n        return [x + offset_x, y + offset_y]\r\n\r\n    def is_in_support_polygon(self, point, polygon):\r\n        """Check if point is in support polygon (simplified)"""\r\n        # Simplified check - in reality, this would be more complex\r\n        if len(polygon) < 2:\r\n            return False\r\n\r\n        # Calculate distance to closest point in polygon\r\n        min_dist = float(\'inf\')\r\n        for p in polygon:\r\n            dist = euclidean(point, p)\r\n            if dist < min_dist:\r\n                min_dist = dist\r\n\r\n        # Consider stable if within step distance\r\n        return min_dist <= self.step_length\r\n\r\nclass AdvancedFootstepPlanner(FootstepPlanner):\r\n    """Advanced footstep planner with stability and terrain considerations"""\r\n\r\n    def __init__(self, step_length=0.3, step_width=0.2):\r\n        super().__init__(step_length, step_width)\r\n        self.max_step_up = 0.1\r\n        self.max_step_down = 0.15\r\n        self.max_com_velocity = 0.5  # m/s\r\n\r\n    def plan_with_terrain(self, start_pose, goal_pose, height_map, obstacles=None):\r\n        """\r\n        Plan footsteps considering terrain elevation and obstacles\r\n        """\r\n        # Use A* or RRT for terrain-aware planning\r\n        path = self.terrain_aware_search(start_pose, goal_pose, height_map, obstacles)\r\n\r\n        # Smooth the path and generate footsteps\r\n        footsteps = self.smooth_path_to_footsteps(path, height_map)\r\n\r\n        return footsteps\r\n\r\n    def terrain_aware_search(self, start, goal, height_map, obstacles):\r\n        """Search for valid path considering terrain constraints"""\r\n        # Simplified implementation - in practice, use proper path planning\r\n        path = [start, goal]\r\n        return path\r\n\r\n    def smooth_path_to_footsteps(self, path, height_map):\r\n        """Convert path to stable footsteps considering terrain"""\r\n        footsteps = []\r\n\r\n        for i in range(len(path) - 1):\r\n            start = path[i]\r\n            end = path[i + 1]\r\n\r\n            # Calculate intermediate steps based on terrain\r\n            step = self.calculate_terrain_aware_step(start, end, height_map)\r\n            footsteps.append(step)\r\n\r\n        return footsteps\r\n\r\n    def calculate_terrain_aware_step(self, start, end, height_map):\r\n        """Calculate step considering terrain constraints"""\r\n        # Check elevation change\r\n        start_height = self.get_terrain_height(start[:2], height_map)\r\n        end_height = self.get_terrain_height(end[:2], height_map)\r\n\r\n        height_diff = abs(end_height - start_height)\r\n\r\n        if height_diff > self.max_step_up:\r\n            # Need to find alternative path or stop\r\n            # For now, return the direct step\r\n            pass\r\n\r\n        return end\r\n\r\n    def get_terrain_height(self, position, height_map):\r\n        """Get terrain height at position"""\r\n        # Simplified - in practice, interpolate from height map\r\n        return 0.0  # Default flat terrain\r\n\r\ndef visualize_footsteps(footsteps, sequence=None):\r\n    """Visualize planned footsteps"""\r\n    if not footsteps:\r\n        return\r\n\r\n    fig, ax = plt.subplots(figsize=(10, 8))\r\n\r\n    # Extract x, y coordinates\r\n    x_coords = [step[0] for step in footsteps]\r\n    y_coords = [step[1] for step in footsteps]\r\n\r\n    ax.plot(x_coords, y_coords, \'b-\', linewidth=2, label=\'Planned Path\')\r\n    ax.scatter(x_coords, y_coords, c=\'red\', s=50, zorder=5, label=\'Footsteps\')\r\n\r\n    # Mark start and end\r\n    ax.scatter(x_coords[0], y_coords[0], c=\'green\', s=100, zorder=6, label=\'Start\')\r\n    ax.scatter(x_coords[-1], y_coords[-1], c=\'red\', s=100, zorder=6, label=\'Goal\')\r\n\r\n    # Draw foot shapes if sequence is provided\r\n    if sequence:\r\n        for step in sequence:\r\n            x, y = step[\'position\'][0], step[\'position\'][1]\r\n            theta = step[\'orientation\']\r\n\r\n            # Draw simple foot shape\r\n            foot_length = 0.15\r\n            foot_width = 0.07\r\n\r\n            # Calculate foot corners\r\n            cos_theta = math.cos(theta)\r\n            sin_theta = math.sin(theta)\r\n\r\n            corners_x = []\r\n            corners_y = []\r\n\r\n            for dx, dy in [(-foot_length/2, -foot_width/2),\r\n                           (foot_length/2, -foot_width/2),\r\n                           (foot_length/2, foot_width/2),\r\n                           (-foot_length/2, foot_width/2),\r\n                           (-foot_length/2, -foot_width/2)]:\r\n                x_corner = x + dx * cos_theta - dy * sin_theta\r\n                y_corner = y + dx * sin_theta + dy * cos_theta\r\n                corners_x.append(x_corner)\r\n                corners_y.append(y_corner)\r\n\r\n            color = \'blue\' if step[\'step_type\'] == \'left\' else \'orange\'\r\n            ax.plot(corners_x, corners_y, color=color, linewidth=1)\r\n\r\n    ax.set_xlabel(\'X (m)\')\r\n    ax.set_ylabel(\'Y (m)\')\r\n    ax.set_title(\'Footstep Planning for Humanoid Navigation\')\r\n    ax.grid(True, alpha=0.3)\r\n    ax.legend()\r\n    ax.axis(\'equal\')\r\n\r\n    plt.tight_layout()\r\n    plt.show()\r\n\r\n# Example usage\r\ndef example_footstep_planning():\r\n    planner = AdvancedFootstepPlanner()\r\n\r\n    # Define start and goal\r\n    start_pose = [0.0, 0.0, 0.0]  # x, y, theta\r\n    goal_pose = [3.0, 2.0, math.pi/4]\r\n\r\n    # Plan footsteps\r\n    footsteps = planner.plan_footsteps(start_pose, goal_pose)\r\n    sequence = planner.plan_bipedal_sequence(footsteps)\r\n\r\n    # Check stability\r\n    is_stable = planner.check_stability(footsteps)\r\n    print(f"Footstep sequence is stable: {is_stable}")\r\n\r\n    # Visualize\r\n    visualize_footsteps(footsteps, sequence)\r\n\r\n    return footsteps, sequence\n'})}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 54 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# python/whole_body_motion_planning.py\r\nimport numpy as np\r\nimport math\r\nfrom scipy.spatial.transform import Rotation as R\r\nfrom scipy.optimize import minimize\r\nimport casadi as cs\r\n\r\nclass WholeBodyMotionPlanner:\r\n    def __init__(self):\r\n        self.robot_params = {\r\n            \'height\': 1.5,  # m\r\n            \'weight\': 60.0, # kg\r\n            \'com_height\': 0.8,  # m (height of center of mass)\r\n            \'foot_size\': [0.25, 0.15]  # length, width\r\n        }\r\n\r\n        self.motion_constraints = {\r\n            \'max_velocity\': 0.5,  # m/s\r\n            \'max_angular_velocity\': 0.5,  # rad/s\r\n            \'max_acceleration\': 1.0,  # m/s^2\r\n            \'max_angular_acceleration\': 1.0  # rad/s^2\r\n        }\r\n\r\n    def plan_whole_body_motion(self, footsteps, start_state, goal_state):\r\n        """\r\n        Plan whole-body motion to execute footsteps while maintaining balance\r\n        """\r\n        # Optimize center of mass trajectory to match footsteps\r\n        com_trajectory = self.optimize_com_trajectory(footsteps, start_state, goal_state)\r\n\r\n        # Generate joint trajectories\r\n        joint_trajectories = self.inverse_kinematics(com_trajectory, footsteps)\r\n\r\n        # Generate balance control commands\r\n        balance_commands = self.generate_balance_control(com_trajectory)\r\n\r\n        return {\r\n            \'com_trajectory\': com_trajectory,\r\n            \'joint_trajectories\': joint_trajectories,\r\n            \'balance_commands\': balance_commands\r\n        }\r\n\r\n    def optimize_com_trajectory(self, footsteps, start_state, goal_state):\r\n        """\r\n        Optimize center of mass trajectory for stable locomotion\r\n        """\r\n        # Use preview control or other methods to generate CoM trajectory\r\n        # that ensures ZMP (Zero Moment Point) stays within support polygon\r\n\r\n        # Simplified approach: generate CoM trajectory that follows footsteps\r\n        # with appropriate smoothing for balance\r\n        com_trajectory = []\r\n\r\n        for i, step in enumerate(footsteps):\r\n            # Calculate desired CoM position based on step location\r\n            # and support polygon\r\n            com_x = step[0]\r\n            com_y = step[1]\r\n            com_z = self.robot_params[\'com_height\']  # Keep CoM at constant height\r\n\r\n            # Add time parameter\r\n            time = i * 0.5  # Assume 0.5s per step\r\n\r\n            com_trajectory.append([time, com_x, com_y, com_z])\r\n\r\n        return com_trajectory\r\n\r\n    def inverse_kinematics(self, com_trajectory, footsteps):\r\n        """\r\n        Calculate joint angles to achieve desired CoM position and foot placement\r\n        """\r\n        joint_trajectories = []\r\n\r\n        for t, com_pos in enumerate(com_trajectory):\r\n            # Calculate required joint angles using inverse kinematics\r\n            # This is a simplified approach - real implementation would use\r\n            # full kinematic model of the humanoid\r\n            joint_angles = self.calculate_joint_angles(com_pos, footsteps, t)\r\n            joint_trajectories.append(joint_angles)\r\n\r\n        return joint_trajectories\r\n\r\n    def calculate_joint_angles(self, com_pos, footsteps, time_idx):\r\n        """\r\n        Calculate joint angles for given CoM position\r\n        """\r\n        # Simplified joint angle calculation\r\n        # In reality, this would solve the full inverse kinematics problem\r\n        joints = {\r\n            \'left_hip\': [0.0, 0.0, 0.0],  # [roll, pitch, yaw]\r\n            \'left_knee\': [0.0],            # [flexion]\r\n            \'left_ankle\': [0.0, 0.0],      # [pitch, roll]\r\n            \'right_hip\': [0.0, 0.0, 0.0],\r\n            \'right_knee\': [0.0],\r\n            \'right_ankle\': [0.0, 0.0],\r\n            \'left_shoulder\': [0.0, 0.0, 0.0],\r\n            \'left_elbow\': [0.0],\r\n            \'right_shoulder\': [0.0, 0.0, 0.0],\r\n            \'right_elbow\': [0.0],\r\n            \'torso\': [0.0, 0.0, 0.0]\r\n        }\r\n\r\n        return joints\r\n\r\n    def generate_balance_control(self, com_trajectory):\r\n        """\r\n        Generate balance control commands to maintain stability\r\n        """\r\n        balance_commands = []\r\n\r\n        for i in range(1, len(com_trajectory)):\r\n            current_com = np.array(com_trajectory[i][1:4])  # x, y, z\r\n            prev_com = np.array(com_trajectory[i-1][1:4])\r\n\r\n            # Calculate CoM velocity\r\n            dt = com_trajectory[i][0] - com_trajectory[i-1][0]\r\n            if dt > 0:\r\n                com_velocity = (current_com - prev_com) / dt\r\n            else:\r\n                com_velocity = np.array([0.0, 0.0, 0.0])\r\n\r\n            # Generate balance command based on CoM state\r\n            balance_cmd = self.calculate_balance_command(current_com, com_velocity)\r\n            balance_commands.append(balance_cmd)\r\n\r\n        return balance_commands\r\n\r\n    def calculate_balance_command(self, com_pos, com_vel):\r\n        """\r\n        Calculate balance command using inverted pendulum model\r\n        """\r\n        # Simplified balance control using linear inverted pendulum model\r\n        # (LIPM) - in reality, this would be more complex\r\n\r\n        # Desired CoM position (based on support polygon)\r\n        desired_com_x = com_pos[0]  # Simplified\r\n        desired_com_y = com_pos[1]\r\n\r\n        # Calculate error\r\n        x_error = desired_com_x - com_pos[0]\r\n        y_error = desired_com_y - com_pos[1]\r\n\r\n        # Simple PD control\r\n        kp = 10.0  # Proportional gain\r\n        kd = 2.0   # Derivative gain (velocity feedback)\r\n\r\n        x_control = kp * x_error - kd * com_vel[0]\r\n        y_control = kp * y_error - kd * com_vel[1]\r\n\r\n        return [x_control, y_control]\r\n\r\nclass PreviewController:\r\n    """\r\n    Implement preview control for humanoid balance during locomotion\r\n    """\r\n    def __init__(self, zmp_delay=0.05, preview_window=1.0):\r\n        self.zmp_delay = zmp_delay\r\n        self.preview_window = preview_window\r\n        self.gravity = 9.81\r\n        self.com_height = 0.8  # m\r\n\r\n        # Calculate omega for LIPM\r\n        self.omega = math.sqrt(self.gravity / self.com_height)\r\n\r\n    def calculate_com_reference(self, zmp_trajectory):\r\n        """\r\n        Calculate CoM reference trajectory from ZMP trajectory using preview control\r\n        """\r\n        # Implement preview control algorithm\r\n        # This ensures ZMP follows desired trajectory while maintaining stability\r\n\r\n        com_reference = []\r\n\r\n        for i, (t, zmp_x, zmp_y) in enumerate(zmp_trajectory):\r\n            # Calculate reference CoM position using preview control\r\n            # This is a simplified implementation\r\n            com_x = zmp_x  # Simplified - in reality, would use full preview control\r\n            com_y = zmp_y\r\n            com_z = self.com_height\r\n\r\n            com_reference.append([t, com_x, com_y, com_z])\r\n\r\n        return com_reference\r\n\r\n    def generate_zmp_trajectory(self, footsteps):\r\n        """\r\n        Generate ZMP trajectory from footsteps\r\n        """\r\n        zmp_trajectory = []\r\n\r\n        for i, step in enumerate(footsteps):\r\n            # Calculate ZMP based on foot placement and timing\r\n            time = i * 0.5  # Assume 0.5s per step\r\n            zmp_x = step[0]\r\n            zmp_y = step[1]\r\n\r\n            zmp_trajectory.append([time, zmp_x, zmp_y])\r\n\r\n        return zmp_trajectory\r\n\r\ndef create_balanced_locomotion_plan(footsteps, start_state, goal_state):\r\n    """\r\n    Create a complete locomotion plan with balance considerations\r\n    """\r\n    # Initialize planners\r\n    wb_planner = WholeBodyMotionPlanner()\r\n    preview_ctrl = PreviewController()\r\n\r\n    # Generate ZMP trajectory from footsteps\r\n    zmp_trajectory = preview_ctrl.generate_zmp_trajectory(footsteps)\r\n\r\n    # Calculate CoM reference using preview control\r\n    com_reference = preview_ctrl.calculate_com_reference(zmp_trajectory)\r\n\r\n    # Plan whole body motion\r\n    motion_plan = wb_planner.plan_whole_body_motion(\r\n        footsteps, start_state, goal_state\r\n    )\r\n\r\n    return {\r\n        \'footsteps\': footsteps,\r\n        \'zmp_trajectory\': zmp_trajectory,\r\n        \'com_reference\': com_reference,\r\n        \'whole_body_plan\': motion_plan\r\n    }\n'})}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 54 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 53 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# python/balance_control.py\r\nimport numpy as np\r\nimport math\r\nfrom scipy.integrate import odeint\r\nfrom scipy.linalg import solve_continuous_are\r\nfrom scipy import signal\r\n\r\nclass BalanceController:\r\n    def __init__(self, robot_height=0.8, control_frequency=100):\r\n        self.com_height = robot_height  # Height of center of mass\r\n        self.control_frequency = control_frequency\r\n        self.gravity = 9.81\r\n\r\n        # State: [x, y, x_dot, y_dot] - CoM position and velocity\r\n        self.state = np.zeros(4)\r\n\r\n        # Calculate LQR gains for inverted pendulum\r\n        self.A = np.array([\r\n            [0, 0, 1, 0],\r\n            [0, 0, 0, 1],\r\n            [self.gravity/self.com_height, 0, 0, 0],\r\n            [0, self.gravity/self.com_height, 0, 0]\r\n        ])\r\n\r\n        # Control input matrix (how control affects acceleration)\r\n        self.B = np.array([\r\n            [0, 0],\r\n            [0, 0],\r\n            [-self.gravity/self.com_height, 0],\r\n            [0, -self.gravity/self.com_height]\r\n        ])\r\n\r\n        # State cost matrix Q (penalizes state deviations)\r\n        self.Q = np.diag([100, 100, 10, 10])  # [x_pos, y_pos, x_vel, y_vel]\r\n\r\n        # Control cost matrix R (penalizes control effort)\r\n        self.R = np.diag([1, 1])  # [x_control, y_control]\r\n\r\n        # Calculate LQR gain matrix\r\n        self.K = self.calculate_lqr_gain()\r\n\r\n    def calculate_lqr_gain(self):\r\n        """Calculate LQR gain matrix for inverted pendulum control"""\r\n        # Solve continuous-time algebraic Riccati equation\r\n        P = solve_continuous_are(self.A, self.B, self.Q, self.R)\r\n\r\n        # LQR gain: u = -K*x\r\n        K = np.linalg.inv(self.R) @ self.B.T @ P\r\n\r\n        return K\r\n\r\n    def update_balance_control(self, current_state, desired_state):\r\n        """\r\n        Update balance control based on current and desired state\r\n        current_state: [com_x, com_y, com_x_dot, com_y_dot]\r\n        desired_state: [des_x, des_y, des_x_dot, des_y_dot]\r\n        """\r\n        # Calculate state error\r\n        state_error = desired_state - current_state\r\n\r\n        # Apply LQR control law: u = -K*(x - x_desired)\r\n        control_output = -self.K @ state_error\r\n\r\n        # Control output represents desired ZMP displacement\r\n        zmp_dx, zmp_dy = control_output\r\n\r\n        return zmp_dx, zmp_dy\r\n\r\n    def integrate_dynamics(self, state, t, zmp_x, zmp_y):\r\n        """\r\n        Integrate inverted pendulum dynamics\r\n        state: [x, y, x_dot, y_dot]\r\n        """\r\n        x, y, x_dot, y_dot = state\r\n\r\n        # Inverted pendulum dynamics\r\n        # x_ddot = g/h * (x - zmp_x)\r\n        # y_ddot = g/h * (y - zmp_y)\r\n        x_ddot = self.gravity/self.com_height * (x - zmp_x)\r\n        y_ddot = self.gravity/self.com_height * (y - zmp_y)\r\n\r\n        return [x_dot, y_dot, x_ddot, y_ddot]\r\n\r\n    def simulate_balance(self, initial_state, zmp_trajectory, dt=0.01):\r\n        """\r\n        Simulate balance control over time\r\n        """\r\n        states = [initial_state]\r\n        times = [0.0]\r\n\r\n        current_state = initial_state.copy()\r\n\r\n        for t in np.arange(0, len(zmp_trajectory)*dt, dt):\r\n            # Get desired ZMP for current time\r\n            idx = min(int(t/dt), len(zmp_trajectory)-1)\r\n            desired_zmp_x, desired_zmp_y = zmp_trajectory[idx]\r\n\r\n            # Calculate control (simplified - in reality, would use full state feedback)\r\n            state_error = current_state - np.array([desired_zmp_x, desired_zmp_y, 0, 0])\r\n            control = -self.K @ state_error\r\n\r\n            # Apply control to ZMP\r\n            actual_zmp_x = desired_zmp_x + control[0]\r\n            actual_zmp_y = desired_zmp_y + control[1]\r\n\r\n            # Integrate dynamics\r\n            derivatives = self.integrate_dynamics(\r\n                current_state, t, actual_zmp_x, actual_zmp_y\r\n            )\r\n\r\n            # Update state (Euler integration)\r\n            new_state = current_state + np.array(derivatives) * dt\r\n            current_state = new_state\r\n\r\n            states.append(new_state.copy())\r\n            times.append(t + dt)\r\n\r\n        return np.array(times), np.array(states)\r\n\r\nclass CapturePointController:\r\n    """\r\n    Capture Point based balance control for humanoid robots\r\n    """\r\n    def __init__(self, com_height=0.8, control_frequency=200):\r\n        self.com_height = com_height\r\n        self.control_frequency = control_frequency\r\n        self.gravity = 9.81\r\n        self.omega = math.sqrt(self.gravity / self.com_height)\r\n\r\n    def calculate_capture_point(self, com_pos, com_vel):\r\n        """\r\n        Calculate capture point from CoM position and velocity\r\n        Capture point = CoM position + CoM velocity / omega\r\n        """\r\n        cp_x = com_pos[0] + com_vel[0] / self.omega\r\n        cp_y = com_pos[1] + com_vel[1] / self.omega\r\n\r\n        return np.array([cp_x, cp_y])\r\n\r\n    def calculate_foot_placement(self, capture_point, current_foot_pos):\r\n        """\r\n        Calculate required foot placement to capture the current state\r\n        """\r\n        # For simplicity, move foot towards capture point\r\n        # In reality, this would consider step constraints and timing\r\n        step_vector = capture_point - current_foot_pos\r\n        max_step_length = 0.3  # Maximum step length\r\n\r\n        if np.linalg.norm(step_vector) > max_step_length:\r\n            step_vector = step_vector / np.linalg.norm(step_vector) * max_step_length\r\n\r\n        new_foot_pos = current_foot_pos + step_vector\r\n\r\n        return new_foot_pos\r\n\r\n    def balance_control_step(self, com_state, support_foot_pos):\r\n        """\r\n        Perform one step of capture point based balance control\r\n        com_state: [x, y, z, x_dot, y_dot, z_dot]\r\n        support_foot_pos: [x, y] of current support foot\r\n        """\r\n        com_pos = com_state[:3]\r\n        com_vel = com_state[3:]\r\n\r\n        # Calculate capture point\r\n        cp = self.calculate_capture_point(com_pos[:2], com_vel[:2])\r\n\r\n        # Determine if step is needed\r\n        foot_to_cp = np.linalg.norm(cp - support_foot_pos)\r\n        stability_threshold = 0.1  # Start planning step when CP is 10cm from foot\r\n\r\n        step_needed = foot_to_cp > stability_threshold\r\n\r\n        return {\r\n            \'capture_point\': cp,\r\n            \'distance_to_foot\': foot_to_cp,\r\n            \'step_needed\': step_needed,\r\n            \'target_foot_placement\': self.calculate_foot_placement(cp, support_foot_pos) if step_needed else support_foot_pos\r\n        }\r\n\r\nclass PendulumController:\r\n    """\r\n    Linear Inverted Pendulum Mode (LIPM) controller\r\n    """\r\n    def __init__(self, com_height=0.8):\r\n        self.com_height = com_height\r\n        self.gravity = 9.81\r\n        self.omega = math.sqrt(self.gravity / self.com_height)\r\n\r\n        # Discrete time model parameters\r\n        self.dt = 0.005  # 200Hz control rate\r\n\r\n    def discrete_dynamics(self, x_k, zmp_k):\r\n        """\r\n        Discrete time inverted pendulum dynamics\r\n        x_k = [com_x, com_x_dot] at time k\r\n        zmp_k = desired ZMP at time k\r\n        """\r\n        # State transition matrix for discrete LIPM\r\n        A_d = np.array([\r\n            [np.cosh(self.omega * self.dt), (1/self.omega) * np.sinh(self.omega * self.dt)],\r\n            [self.omega * np.sinh(self.omega * self.dt), np.cosh(self.omega * self.dt)]\r\n        ])\r\n\r\n        # Input matrix\r\n        B_d = np.array([\r\n            [1 - np.cosh(self.omega * self.dt)],\r\n            [-self.omega * np.sinh(self.omega * self.dt)]\r\n        ])\r\n\r\n        # Next state\r\n        x_k1 = A_d @ x_k + B_d * zmp_k\r\n\r\n        return x_k1\r\n\r\n    def mpc_balance_control(self, current_state, reference_trajectory, horizon=20):\r\n        """\r\n        Model Predictive Control for balance using LIPM\r\n        """\r\n        # Simplified MPC implementation\r\n        # In reality, this would solve a constrained optimization problem\r\n\r\n        predicted_states = []\r\n        control_inputs = []\r\n\r\n        current_x = current_state.copy()\r\n\r\n        for k in range(horizon):\r\n            # Get reference for this step\r\n            if k < len(reference_trajectory):\r\n                ref_state = reference_trajectory[k]\r\n            else:\r\n                ref_state = reference_trajectory[-1]  # Hold last reference\r\n\r\n            # Simple control law (in reality, would solve MPC optimization)\r\n            zmp_ref = ref_state[0]  # Reference ZMP\r\n            current_zmp = current_x[0]  # Current CoM position\r\n\r\n            # Proportional control to track reference\r\n            zmp_cmd = zmp_ref + 0.1 * (current_zmp - ref_state[0])\r\n\r\n            # Apply dynamics\r\n            next_x = self.discrete_dynamics(current_x, zmp_cmd)\r\n\r\n            predicted_states.append(next_x.copy())\r\n            control_inputs.append(zmp_cmd)\r\n\r\n            current_x = next_x\r\n\r\n        # Return first control input\r\n        return control_inputs[0] if control_inputs else 0.0\r\n\r\ndef demonstrate_balance_control():\r\n    """\r\n    Demonstrate different balance control approaches\r\n    """\r\n    print("Demonstrating Balance Control Approaches")\r\n\r\n    # Initialize controllers\r\n    lqr_controller = BalanceController()\r\n    cp_controller = CapturePointController()\r\n    lipm_controller = PendulumController()\r\n\r\n    # Example CoM state [x, y, x_dot, y_dot]\r\n    com_state = np.array([0.05, 0.02, 0.1, -0.05])  # Slightly perturbed\r\n\r\n    # Example desired state\r\n    desired_state = np.array([0.0, 0.0, 0.0, 0.0])  # At equilibrium\r\n\r\n    # Calculate LQR control\r\n    zmp_dx, zmp_dy = lqr_controller.update_balance_control(com_state, desired_state)\r\n    print(f"LQR Control - ZMP adjustment: ({zmp_dx:.3f}, {zmp_dy:.3f})")\r\n\r\n    # Example CoM state for capture point controller [x, y, z, x_dot, y_dot, z_dot]\r\n    full_com_state = np.array([0.05, 0.02, 0.8, 0.1, -0.05, 0.0])\r\n    support_foot = np.array([0.0, 0.0])\r\n\r\n    cp_result = cp_controller.balance_control_step(full_com_state, support_foot)\r\n    print(f"Capture Point: ({cp_result[\'capture_point\'][0]:.3f}, {cp_result[\'capture_point\'][1]:.3f})")\r\n    print(f"Step needed: {cp_result[\'step_needed\']}")\r\n\r\n    return lqr_controller, cp_controller, lipm_controller\n'})}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 53 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 52 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# python/humanoid_behavior_trees.py\r\nimport py_trees\r\nimport py_trees_ros\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav_msgs.msg import Path\r\nfrom std_msgs.msg import String\r\nimport time\r\n\r\nclass HumanoidNavigateToPoseAction(py_trees_ros.actions.ActionClient):\r\n    """\r\n    Custom action client for humanoid navigation to pose\r\n    """\r\n    def __init__(self, name, action_type, action_name, goal):\r\n        super().__init__(name=name, action_type=action_type, action_name=action_name, goal=goal)\r\n        self.feedback_message = "initialised"\r\n\r\n    def update(self):\r\n        # Check if action server is available\r\n        if not self.action_client.server_is_ready():\r\n            return py_trees.Status.RUNNING\r\n\r\n        # Send goal if not already sent\r\n        if self.sent_goal is False:\r\n            self.send_goal()\r\n            return py_trees.Status.RUNNING\r\n\r\n        # Check goal status\r\n        if self.goal_handle.status == GoalStatus.STATUS_SUCCEEDED:\r\n            self.feedback_message = "arrived at goal"\r\n            return py_trees.Status.SUCCESS\r\n        elif self.goal_handle.status == GoalStatus.STATUS_EXECUTING:\r\n            self.feedback_message = "moving to goal"\r\n            return py_trees.Status.RUNNING\r\n        else:\r\n            self.feedback_message = "navigation failed"\r\n            return py_trees.Status.FAILURE\r\n\r\nclass CheckFootSupport(py_trees.behaviour.Behaviour):\r\n    """\r\n    Check if the robot has proper foot support before navigation\r\n    """\r\n    def __init__(self, name):\r\n        super().__init__(name)\r\n        self.blackboard = py_trees.blackboard.Blackboard()\r\n\r\n    def setup(self, **kwargs):\r\n        # Initialize any required resources\r\n        pass\r\n\r\n    def update(self):\r\n        # Check if robot has stable foot support\r\n        # This would interface with robot state\r\n        has_support = self.check_robot_support()\r\n\r\n        if has_support:\r\n            return py_trees.Status.SUCCESS\r\n        else:\r\n            return py_trees.Status.FAILURE\r\n\r\n    def check_robot_support(self):\r\n        # Simulate checking for foot support\r\n        # In reality, this would check robot\'s balance state\r\n        return True  # Assume stable for example\r\n\r\nclass PlanFootsteps(py_trees.behaviour.Behaviour):\r\n    """\r\n    Plan safe footsteps to the goal\r\n    """\r\n    def __init__(self, name):\r\n        super().__init__(name)\r\n        self.blackboard = py_trees.blackboard.Blackboard()\r\n\r\n    def setup(self, **kwargs):\r\n        # Initialize footstep planner\r\n        self.footstep_planner = FootstepPlanner()\r\n\r\n    def update(self):\r\n        # Get goal from blackboard\r\n        goal = self.blackboard.get("navigation_goal")\r\n\r\n        if goal is None:\r\n            return py_trees.Status.FAILURE\r\n\r\n        # Plan footsteps\r\n        start_pose = [0.0, 0.0, 0.0]  # Current pose\r\n        footsteps = self.footstep_planner.plan_footsteps(start_pose, goal)\r\n\r\n        if footsteps:\r\n            self.blackboard.set("footsteps", footsteps)\r\n            self.feedback_message = f"Planned {len(footsteps)} footsteps"\r\n            return py_trees.Status.SUCCESS\r\n        else:\r\n            return py_trees.Status.FAILURE\r\n\r\nclass ExecuteFootsteps(py_trees.behaviour.Behaviour):\r\n    """\r\n    Execute planned footsteps with balance control\r\n    """\r\n    def __init__(self, name):\r\n        super().__init__(name)\r\n        self.blackboard = py_trees.blackboard.Blackboard()\r\n\r\n    def setup(self, **kwargs):\r\n        # Initialize balance controller\r\n        self.balance_controller = BalanceController()\r\n\r\n    def update(self):\r\n        footsteps = self.blackboard.get("footsteps")\r\n\r\n        if not footsteps:\r\n            return py_trees.Status.FAILURE\r\n\r\n        # Execute footsteps one by one\r\n        current_step_idx = self.blackboard.get("current_step", 0)\r\n\r\n        if current_step_idx >= len(footsteps):\r\n            # All footsteps executed\r\n            return py_trees.Status.SUCCESS\r\n\r\n        # Execute current step with balance control\r\n        success = self.execute_single_step(footsteps[current_step_idx])\r\n\r\n        if success:\r\n            self.blackboard.set("current_step", current_step_idx + 1)\r\n            self.feedback_message = f"Completed step {current_step_idx + 1}"\r\n            return py_trees.Status.RUNNING  # Continue to next step\r\n        else:\r\n            return py_trees.Status.FAILURE\r\n\r\n    def execute_single_step(self, step):\r\n        # Simulate executing a single step with balance control\r\n        # In reality, this would interface with robot\'s walking controller\r\n        time.sleep(0.1)  # Simulate step execution time\r\n        return True  # Assume success for example\r\n\r\nclass HumanoidNavigationSelector(py_trees.composites.Selector):\r\n    """\r\n    Selector for humanoid navigation behaviors\r\n    """\r\n    def __init__(self, name):\r\n        super().__init__(name)\r\n\r\n        # Add child behaviors\r\n        self.add_child(CheckFootSupport("CheckSupport"))\r\n        self.add_child(PlanFootsteps("PlanFootsteps"))\r\n        self.add_child(ExecuteFootsteps("ExecuteFootsteps"))\r\n\r\ndef create_humanoid_navigation_tree():\r\n    """\r\n    Create a behavior tree for humanoid navigation\r\n    """\r\n    # Main root\r\n    root = py_trees.composites.Sequence(name="HumanoidNavigation")\r\n\r\n    # Add selector for navigation behaviors\r\n    nav_selector = HumanoidNavigationSelector("NavigationSelector")\r\n    root.add_child(nav_selector)\r\n\r\n    # Add goal setting (in practice, this would come from external source)\r\n    set_goal = py_trees.behaviours.Success("SetGoal")\r\n    root.insert_child(set_goal, index=0)\r\n\r\n    return root\r\n\r\nclass BehaviorTreeManager(Node):\r\n    """\r\n    Manage the behavior tree execution\r\n    """\r\n    def __init__(self):\r\n        super().__init__(\'behavior_tree_manager\')\r\n\r\n        # Create the behavior tree\r\n        self.tree = create_humanoid_navigation_tree()\r\n\r\n        # Setup tree visitor for debugging\r\n        self.snapshot_visitor = py_trees.visitors.SnapshotVisitor()\r\n\r\n        # Timer for tree ticking\r\n        self.timer = self.create_timer(0.1, self.tick_tree)\r\n\r\n        self.get_logger().info("Behavior Tree Manager initialized")\r\n\r\n    def tick_tree(self):\r\n        """\r\n        Tick the behavior tree\r\n        """\r\n        # Tick the tree\r\n        self.tree.tick_once()\r\n\r\n        # Visit the tree to get feedback\r\n        self.tree.visit(self.snapshot_visitor)\r\n\r\n        # Print tree status\r\n        print(py_trees.display.unicode_tree(\r\n            root=self.tree,\r\n            visited=self.snapshot_visitor.visited,\r\n            previously_visited=self.snapshot_visitor.previously_visited\r\n        ))\r\n\r\n        # Check if tree has reached a conclusion\r\n        if self.tree.status == py_trees.common.Status.SUCCESS:\r\n            self.get_logger().info("Navigation task completed successfully")\r\n        elif self.tree.status == py_trees.common.Status.FAILURE:\r\n            self.get_logger().error("Navigation task failed")\r\n\r\n        # Reset tree if completed\r\n        if self.tree.status in [py_trees.common.Status.SUCCESS, py_trees.common.Status.FAILURE]:\r\n            self.tree.tip().stop(py_trees.common.Status.INVALID)\r\n            self.tree.reset()\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    # Initialize behavior tree manager\r\n    bt_manager = BehaviorTreeManager()\r\n\r\n    try:\r\n        rclpy.spin(bt_manager)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        bt_manager.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 52 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 51 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# python/navigation_optimization.py\r\nimport numpy as np\r\nimport time\r\nimport threading\r\nfrom collections import deque\r\nimport multiprocessing as mp\r\nfrom numba import jit, cuda\r\nimport ctypes\r\n\r\nclass RealTimeNavigationOptimizer:\r\n    """\r\n    Optimize navigation algorithms for real-time humanoid locomotion\r\n    """\r\n    def __init__(self):\r\n        self.control_frequency = 200  # Hz\r\n        self.planning_frequency = 10  # Hz\r\n        self.safety_frequency = 100   # Hz\r\n\r\n        # Real-time constraints\r\n        self.max_control_time = 1.0 / self.control_frequency  # seconds\r\n        self.max_planning_time = 1.0 / self.planning_frequency\r\n        self.max_safety_time = 1.0 / self.safety_frequency\r\n\r\n        # Threading for parallel processing\r\n        self.control_thread = None\r\n        self.planning_thread = None\r\n        self.safety_thread = None\r\n\r\n        # Data buffers\r\n        self.sensor_data = deque(maxlen=10)\r\n        self.trajectory_buffer = deque(maxlen=5)\r\n        self.control_commands = deque(maxlen=5)\r\n\r\n    @jit(nopython=True)\r\n    def fast_distance_calculation(self, p1, p2):\r\n        """Fast distance calculation using Numba"""\r\n        dx = p1[0] - p2[0]\r\n        dy = p1[1] - p2[1]\r\n        return np.sqrt(dx*dx + dy*dy)\r\n\r\n    @jit(nopython=True)\r\n    def fast_vector_operations(self, v1, v2):\r\n        """Fast vector operations using Numba"""\r\n        # Add two vectors\r\n        result = np.empty(2)\r\n        result[0] = v1[0] + v2[0]\r\n        result[1] = v1[1] + v2[1]\r\n        return result\r\n\r\n    def run_control_loop(self):\r\n        """Run the real-time control loop"""\r\n        rate = 1.0 / self.control_frequency\r\n\r\n        while True:\r\n            start_time = time.time()\r\n\r\n            try:\r\n                # Execute control algorithm\r\n                control_cmd = self.execute_control_algorithm()\r\n\r\n                # Add to command buffer\r\n                self.control_commands.append(control_cmd)\r\n\r\n                # Maintain real-time constraint\r\n                elapsed = time.time() - start_time\r\n                sleep_time = max(0, rate - elapsed)\r\n\r\n                if sleep_time > 0:\r\n                    time.sleep(sleep_time)\r\n\r\n            except Exception as e:\r\n                self.get_logger().error(f"Control loop error: {e}")\r\n                time.sleep(rate)\r\n\r\n    def execute_control_algorithm(self):\r\n        """Execute the main control algorithm"""\r\n        # Simplified control algorithm\r\n        # In reality, this would implement the full control law\r\n\r\n        # Get latest sensor data\r\n        if self.sensor_data:\r\n            latest_data = self.sensor_data[-1]\r\n        else:\r\n            return np.zeros(6)  # Default command\r\n\r\n        # Calculate control output (simplified)\r\n        control_output = np.zeros(6)  # [x_vel, y_vel, theta_vel, com_x, com_y, com_z]\r\n\r\n        # Apply control law\r\n        # This would implement the balance control algorithm\r\n        control_output[0] = latest_data.get(\'desired_x_vel\', 0.0)\r\n        control_output[1] = latest_data.get(\'desired_y_vel\', 0.0)\r\n        control_output[2] = latest_data.get(\'desired_theta_vel\', 0.0)\r\n\r\n        return control_output\r\n\r\n    def run_planning_loop(self):\r\n        """Run the path planning loop"""\r\n        rate = 1.0 / self.planning_frequency\r\n\r\n        while True:\r\n            start_time = time.time()\r\n\r\n            try:\r\n                # Execute planning algorithm\r\n                new_plan = self.execute_planning_algorithm()\r\n\r\n                # Add to trajectory buffer\r\n                if new_plan is not None:\r\n                    self.trajectory_buffer.append(new_plan)\r\n\r\n                # Maintain real-time constraint\r\n                elapsed = time.time() - start_time\r\n                sleep_time = max(0, rate - elapsed)\r\n\r\n                if sleep_time > 0:\r\n                    time.sleep(sleep_time)\r\n\r\n            except Exception as e:\r\n                self.get_logger().error(f"Planning loop error: {e}")\r\n                time.sleep(rate)\r\n\r\n    def execute_planning_algorithm(self):\r\n        """Execute the path planning algorithm"""\r\n        # Simplified planning algorithm\r\n        # In reality, this would implement A*, RRT, or other planners\r\n\r\n        # Check for new goal\r\n        goal = self.get_latest_goal()\r\n        if goal is None:\r\n            return None\r\n\r\n        # Get current state\r\n        current_state = self.get_current_state()\r\n\r\n        # Plan path (simplified)\r\n        path = self.plan_path_fast(current_state, goal)\r\n\r\n        return path\r\n\r\n    def plan_path_fast(self, start, goal):\r\n        """Fast path planning (simplified)"""\r\n        # Use a fast but potentially suboptimal planner\r\n        # For real-time applications, prioritize speed over optimality\r\n\r\n        # Simplified straight-line path with obstacle avoidance\r\n        path = [start, goal]\r\n        return path\r\n\r\n    def run_safety_loop(self):\r\n        """Run the safety monitoring loop"""\r\n        rate = 1.0 / self.safety_frequency\r\n\r\n        while True:\r\n            start_time = time.time()\r\n\r\n            try:\r\n                # Check safety conditions\r\n                safety_status = self.check_safety_conditions()\r\n\r\n                # Handle safety violations\r\n                if not safety_status[\'is_safe\']:\r\n                    self.emergency_stop()\r\n\r\n                # Maintain real-time constraint\r\n                elapsed = time.time() - start_time\r\n                sleep_time = max(0, rate - elapsed)\r\n\r\n                if sleep_time > 0:\r\n                    time.sleep(sleep_time)\r\n\r\n            except Exception as e:\r\n                self.get_logger().error(f"Safety loop error: {e}")\r\n                self.emergency_stop()\r\n                time.sleep(rate)\r\n\r\n    def check_safety_conditions(self):\r\n        """Check various safety conditions"""\r\n        safety_status = {\r\n            \'is_safe\': True,\r\n            \'balance_safe\': True,\r\n            \'collision_safe\': True,\r\n            \'hardware_safe\': True\r\n        }\r\n\r\n        # Check balance\r\n        balance_ok = self.check_balance_safety()\r\n        safety_status[\'balance_safe\'] = balance_ok\r\n        safety_status[\'is_safe\'] &= balance_ok\r\n\r\n        # Check for collisions\r\n        collision_ok = self.check_collision_safety()\r\n        safety_status[\'collision_safe\'] = collision_ok\r\n        safety_status[\'is_safe\'] &= collision_ok\r\n\r\n        # Check hardware status\r\n        hardware_ok = self.check_hardware_safety()\r\n        safety_status[\'hardware_safe\'] = hardware_ok\r\n        safety_status[\'is_safe\'] &= hardware_ok\r\n\r\n        return safety_status\r\n\r\n    def check_balance_safety(self):\r\n        """Check if robot is in safe balance state"""\r\n        # Simplified balance check\r\n        # In reality, this would check ZMP, CoM position, etc.\r\n        return True\r\n\r\n    def check_collision_safety(self):\r\n        """Check for potential collisions"""\r\n        # Simplified collision check\r\n        # In reality, this would process sensor data\r\n        return True\r\n\r\n    def check_hardware_safety(self):\r\n        """Check hardware status"""\r\n        # Simplified hardware check\r\n        # In reality, this would check joint limits, temperatures, etc.\r\n        return True\r\n\r\n    def emergency_stop(self):\r\n        """Execute emergency stop procedure"""\r\n        self.get_logger().error("EMERGENCY STOP ACTIVATED")\r\n        # Send zero commands to all actuators\r\n        # This would interface with the robot\'s safety system\r\n\r\n    def get_latest_goal(self):\r\n        """Get the latest navigation goal"""\r\n        # In reality, this would get goal from ROS topics\r\n        return None\r\n\r\n    def get_current_state(self):\r\n        """Get the current robot state"""\r\n        # In reality, this would get state from odometry, IMU, etc.\r\n        return [0.0, 0.0, 0.0]\r\n\r\n    def start_real_time_loops(self):\r\n        """Start all real-time loops in separate threads"""\r\n        # Start control loop\r\n        self.control_thread = threading.Thread(target=self.run_control_loop, daemon=True)\r\n        self.control_thread.start()\r\n\r\n        # Start planning loop\r\n        self.planning_thread = threading.Thread(target=self.run_planning_loop, daemon=True)\r\n        self.planning_thread.start()\r\n\r\n        # Start safety loop\r\n        self.safety_thread = threading.Thread(target=self.run_safety_loop, daemon=True)\r\n        self.safety_thread.start()\r\n\r\nclass MultiProcessNavigation:\r\n    """\r\n    Multi-process navigation system for better real-time performance\r\n    """\r\n    def __init__(self):\r\n        self.processes = []\r\n        self.shared_memory = {}\r\n\r\n    def create_navigation_process(self):\r\n        """Create a dedicated process for navigation"""\r\n        # This would create a process with real-time priority\r\n        # and dedicated CPU core if possible\r\n        pass\r\n\r\n    def setup_shared_memory(self):\r\n        """Setup shared memory for inter-process communication"""\r\n        # Use multiprocessing shared memory for low-latency communication\r\n        pass\r\n\r\ndef optimize_for_real_time():\r\n    """\r\n    Apply various optimizations for real-time performance\r\n    """\r\n    optimizer = RealTimeNavigationOptimizer()\r\n\r\n    # Apply Numba optimizations\r\n    # The @jit decorators above will compile functions to machine code\r\n\r\n    # Start real-time loops\r\n    optimizer.start_real_time_loops()\r\n\r\n    # Monitor performance\r\n    monitor = PerformanceMonitor()\r\n    monitor.start_monitoring()\r\n\r\n    return optimizer\r\n\r\nclass PerformanceMonitor:\r\n    """\r\n    Monitor navigation system performance\r\n    """\r\n    def __init__(self):\r\n        self.metrics = {\r\n            \'control_loop_times\': deque(maxlen=1000),\r\n            \'planning_times\': deque(maxlen=100),\r\n            \'loop_rates\': deque(maxlen=1000),\r\n            \'memory_usage\': deque(maxlen=1000)\r\n        }\r\n        self.start_time = time.time()\r\n\r\n    def start_monitoring(self):\r\n        """Start performance monitoring"""\r\n        import psutil\r\n        import threading\r\n\r\n        def monitor_loop():\r\n            while True:\r\n                # Record current time\r\n                current_time = time.time()\r\n\r\n                # Monitor memory usage\r\n                process = psutil.Process()\r\n                memory_mb = process.memory_info().rss / 1024 / 1024\r\n                self.metrics[\'memory_usage\'].append(memory_mb)\r\n\r\n                # Calculate loop rate\r\n                elapsed = current_time - self.start_time\r\n                if elapsed > 0:\r\n                    rate = len(self.metrics[\'loop_rates\']) / elapsed\r\n                    self.metrics[\'loop_rates\'].append(rate)\r\n\r\n                time.sleep(1.0)  # Update every second\r\n\r\n        monitor_thread = threading.Thread(target=monitor_loop, daemon=True)\r\n        monitor_thread.start()\r\n\r\n    def get_performance_report(self):\r\n        """Get current performance metrics"""\r\n        if not self.metrics[\'loop_rates\']:\r\n            return "No data available"\r\n\r\n        avg_rate = sum(self.metrics[\'loop_rates\']) / len(self.metrics[\'loop_rates\'])\r\n        max_memory = max(self.metrics[\'memory_usage\']) if self.metrics[\'memory_usage\'] else 0\r\n\r\n        report = f"""\r\n        Performance Report:\r\n        - Average Loop Rate: {avg_rate:.2f} Hz\r\n        - Max Memory Usage: {max_memory:.2f} MB\r\n        - Control Loop Samples: {len(self.metrics[\'control_loop_times\'])}\r\n        - Planning Samples: {len(self.metrics[\'planning_times\'])}\r\n        """\r\n\r\n        return report\r\n\r\n# Example usage\r\ndef run_optimized_navigation():\r\n    """\r\n    Run the optimized navigation system\r\n    """\r\n    print("Starting optimized humanoid navigation system...")\r\n\r\n    # Initialize optimizer\r\n    nav_optimizer = optimize_for_real_time()\r\n\r\n    # Run for a while\r\n    time.sleep(10)\r\n\r\n    # Print performance report\r\n    monitor = PerformanceMonitor()\r\n    print(monitor.get_performance_report())\r\n\r\n    return nav_optimizer\n'})}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 51 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 51 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# python/isaac_sim_nav_integration.py\r\nfrom omni.isaac.core import World\r\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\r\nfrom omni.isaac.core.robots import Robot\r\nfrom omni.isaac.core.objects import DynamicCuboid\r\nfrom omni.isaac.core.prims import RigidPrim\r\nfrom omni.isaac.core.utils.prims import get_prim_at_path\r\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\r\nfrom omni.isaac.core.utils.viewports import set_camera_view\r\nimport numpy as np\r\nimport math\r\nimport rclpy\r\nfrom geometry_msgs.msg import PoseStamped, Twist\r\nfrom nav_msgs.msg import Odometry, Path\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom std_msgs.msg import String\r\n\r\nclass IsaacSimNavigationInterface:\r\n    """\r\n    Interface between Isaac Sim and ROS 2 for humanoid navigation\r\n    """\r\n    def __init__(self, robot_name="humanoid_robot", stage_units_in_meters=1.0):\r\n        # Isaac Sim components\r\n        self.world = World(stage_units_in_meters=stage_units_in_meters)\r\n        self.robot = None\r\n        self.robot_name = robot_name\r\n\r\n        # ROS 2 components (will be initialized later)\r\n        self.ros_node = None\r\n        self.ros_initialized = False\r\n\r\n        # Navigation state\r\n        self.current_goal = None\r\n        self.navigation_active = False\r\n        self.robot_pose = np.array([0.0, 0.0, 0.0])  # x, y, theta\r\n\r\n    def setup_isaac_sim_environment(self):\r\n        """Setup Isaac Sim environment with humanoid robot"""\r\n        # Get assets root path\r\n        assets_root_path = get_assets_root_path()\r\n        if assets_root_path is None:\r\n            raise Exception("Could not find Isaac Sim assets path")\r\n\r\n        # Add ground plane\r\n        self.world.scene.add_default_ground_plane()\r\n\r\n        # Add humanoid robot (using a simple model for demonstration)\r\n        robot_path = f"{assets_root_path}/Isaac/Robots/Franka/fr3.usd"\r\n        add_reference_to_stage(usd_path=robot_path, prim_path="/World/Robot")\r\n\r\n        # Initialize robot in Isaac Sim\r\n        self.robot = self.world.scene.get_object("Robot")\r\n\r\n        # Add obstacles to the environment\r\n        self.add_obstacles()\r\n\r\n        # Setup camera for visualization\r\n        set_camera_view(eye=[2.0, 2.0, 2.0], target=[0.0, 0.0, 0.0])\r\n\r\n    def add_obstacles(self):\r\n        """Add obstacles to the environment"""\r\n        # Add some simple obstacles\r\n        obstacles = [\r\n            {"name": "box1", "position": [1.0, 0.0, 0.1], "size": [0.2, 0.2, 0.2]},\r\n            {"name": "box2", "position": [0.0, 1.0, 0.1], "size": [0.2, 0.2, 0.2]},\r\n            {"name": "box3", "position": [-1.0, -1.0, 0.1], "size": [0.2, 0.2, 0.2]},\r\n        ]\r\n\r\n        for obs in obstacles:\r\n            DynamicCuboid(\r\n                prim_path=f"/World/{obs[\'name\']}",\r\n                name=obs[\'name\'],\r\n                position=obs[\'position\'],\r\n                size=obs[\'size\'],\r\n                color=np.array([0.5, 0.5, 0.5])\r\n            )\r\n\r\n    def initialize_ros_interface(self):\r\n        """Initialize ROS 2 interface"""\r\n        if not self.ros_initialized:\r\n            rclpy.init()\r\n            self.ros_node = IsaacSimRosBridge()\r\n            self.ros_initialized = True\r\n\r\n    def run_navigation_simulation(self):\r\n        """Run the navigation simulation loop"""\r\n        # Reset the world\r\n        self.world.reset()\r\n\r\n        # Initialize ROS interface\r\n        self.initialize_ros_interface()\r\n\r\n        # Main simulation loop\r\n        sim_step = 0\r\n        while True:\r\n            # Step Isaac Sim\r\n            self.world.step(render=True)\r\n\r\n            # Update robot pose\r\n            self.update_robot_pose()\r\n\r\n            # Process ROS messages\r\n            if self.ros_node:\r\n                try:\r\n                    rclpy.spin_once(self.ros_node, timeout_sec=0)\r\n                except KeyboardInterrupt:\r\n                    break\r\n\r\n            # Process navigation commands\r\n            self.process_navigation_commands()\r\n\r\n            # Log progress\r\n            if sim_step % 100 == 0:\r\n                print(f"Simulation step: {sim_step}, Robot pose: {self.robot_pose}")\r\n\r\n            sim_step += 1\r\n\r\n            # Limit simulation steps for demo\r\n            if sim_step > 5000:  # Run for 5000 steps then stop\r\n                break\r\n\r\n    def update_robot_pose(self):\r\n        """Update robot pose from Isaac Sim"""\r\n        if self.robot:\r\n            # Get current pose from Isaac Sim\r\n            pose = self.robot.get_world_poses()\r\n            if pose:\r\n                positions, orientations = pose\r\n                if len(positions) > 0:\r\n                    pos = positions[0]\r\n                    # Simplified: extract x, y position and approximate theta\r\n                    self.robot_pose[0] = float(pos[0])\r\n                    self.robot_pose[1] = float(pos[1])\r\n\r\n                    # For theta, we\'d need orientation information\r\n                    # Simplified for this example\r\n                    self.robot_pose[2] = 0.0  # Placeholder\r\n\r\n    def process_navigation_commands(self):\r\n        """Process navigation commands from ROS"""\r\n        if self.current_goal is not None and self.navigation_active:\r\n            # Calculate distance to goal\r\n            dx = self.current_goal[0] - self.robot_pose[0]\r\n            dy = self.current_goal[1] - self.robot_pose[1]\r\n            distance = math.sqrt(dx*dx + dy*dy)\r\n\r\n            # Check if reached goal\r\n            if distance < 0.2:  # 20cm threshold\r\n                self.navigation_active = False\r\n                if self.ros_node:\r\n                    self.ros_node.publish_navigation_status("GOAL_REACHED")\r\n            else:\r\n                # Send movement command towards goal\r\n                self.move_towards_goal(dx, dy)\r\n\r\n    def move_towards_goal(self, dx, dy):\r\n        """Send command to move robot towards goal"""\r\n        if self.ros_node:\r\n            # Calculate desired velocity\r\n            speed = min(0.2, math.sqrt(dx*dx + dy*dy) * 2.0)  # Proportional control\r\n            angle = math.atan2(dy, dx)\r\n\r\n            # Create twist message\r\n            twist_msg = Twist()\r\n            twist_msg.linear.x = speed * math.cos(angle - self.robot_pose[2])\r\n            twist_msg.angular.z = angle - self.robot_pose[2]\r\n\r\n            # Publish command\r\n            self.ros_node.publish_velocity_command(twist_msg)\r\n\r\nclass IsaacSimRosBridge(Node):\r\n    """\r\n    ROS 2 bridge node for Isaac Sim integration\r\n    """\r\n    def __init__(self):\r\n        super().__init__(\'isaac_sim_nav_bridge\')\r\n\r\n        # Publishers\r\n        self.odom_pub = self.create_publisher(Odometry, \'/odom\', 10)\r\n        self.scan_pub = self.create_publisher(LaserScan, \'/scan\', 10)\r\n        self.status_pub = self.create_publisher(String, \'/nav_status\', 10)\r\n\r\n        # Subscribers\r\n        self.goal_sub = self.create_subscription(\r\n            PoseStamped,\r\n            \'/move_base_simple/goal\',\r\n            self.goal_callback,\r\n            10\r\n        )\r\n\r\n        self.cmd_vel_sub = self.create_subscription(\r\n            Twist,\r\n            \'/cmd_vel\',\r\n            self.cmd_vel_callback,\r\n            10\r\n        )\r\n\r\n        # Timer for publishing sensor data\r\n        self.timer = self.create_timer(0.1, self.publish_sensor_data)\r\n\r\n        self.get_logger().info("Isaac Sim ROS Bridge initialized")\r\n\r\n    def goal_callback(self, msg):\r\n        """Handle navigation goal from ROS"""\r\n        goal = [msg.pose.position.x, msg.pose.position.y, 0.0]\r\n        self.get_logger().info(f"Received navigation goal: {goal}")\r\n\r\n        # This would be passed to the navigation system\r\n        # For now, we\'ll just log it\r\n\r\n    def cmd_vel_callback(self, msg):\r\n        """Handle velocity commands from ROS"""\r\n        self.get_logger().info(f"Received velocity command: {msg.linear.x}, {msg.angular.z}")\r\n\r\n        # This would be sent to the robot in Isaac Sim\r\n        # For now, we\'ll just log it\r\n\r\n    def publish_sensor_data(self):\r\n        """Publish sensor data from Isaac Sim"""\r\n        # Publish odometry (simplified)\r\n        odom_msg = Odometry()\r\n        odom_msg.header.stamp = self.get_clock().now().to_msg()\r\n        odom_msg.header.frame_id = \'odom\'\r\n        odom_msg.child_frame_id = \'base_link\'\r\n\r\n        # Publish dummy data for demonstration\r\n        odom_msg.pose.pose.position.x = 0.0\r\n        odom_msg.pose.pose.position.y = 0.0\r\n        odom_msg.pose.pose.position.z = 0.0\r\n\r\n        self.odom_pub.publish(odom_msg)\r\n\r\n        # Publish dummy laser scan\r\n        scan_msg = LaserScan()\r\n        scan_msg.header.stamp = self.get_clock().now().to_msg()\r\n        scan_msg.header.frame_id = \'laser_frame\'\r\n        scan_msg.angle_min = -math.pi/2\r\n        scan_msg.angle_max = math.pi/2\r\n        scan_msg.angle_increment = math.pi/180  # 1 degree\r\n        scan_msg.range_min = 0.1\r\n        scan_msg.range_max = 10.0\r\n        scan_msg.ranges = [5.0] * 181  # 181 points\r\n\r\n        self.scan_pub.publish(scan_msg)\r\n\r\n    def publish_navigation_status(self, status):\r\n        """Publish navigation status"""\r\n        status_msg = String()\r\n        status_msg.data = status\r\n        self.status_pub.publish(status_msg)\r\n\r\n    def publish_velocity_command(self, twist_msg):\r\n        """Publish velocity command to robot"""\r\n        # This would send the command to Isaac Sim robot\r\n        pass\r\n\r\ndef main():\r\n    """Main function to run Isaac Sim navigation integration"""\r\n    print("Setting up Isaac Sim navigation environment...")\r\n\r\n    # Create navigation interface\r\n    nav_interface = IsaacSimNavigationInterface()\r\n\r\n    # Setup Isaac Sim environment\r\n    nav_interface.setup_isaac_sim_environment()\r\n\r\n    # Run simulation\r\n    print("Starting navigation simulation...")\r\n    nav_interface.run_navigation_simulation()\r\n\r\n    print("Navigation simulation completed.")\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 50 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 50 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 49 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 49 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 48 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 48 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 48 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 47 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 47 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 46 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 46 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 45 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 45 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 44 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 44 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 44 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 43 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 43 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 42 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 42 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 41 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 41 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 40 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 40 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 40 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 39 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 39 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 38 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 38 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 37 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 37 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 36 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 36 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 36 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 35 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 35 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 34 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 34 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 34 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 34 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 34 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 33 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]}),"\n",(0,o.jsxs)(e.p,{children:["MYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 33 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 32 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE\r\nMYMEMORY WARNING: YOU USED ALL AVAILABLE FREE TRANSLATIONS FOR TODAY. NEXT AVAILABLE IN  20 HOURS 06 MINUTES 32 SECONDS VISIT ",(0,o.jsx)(e.a,{href:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP",children:"HTTPS://MYMEMORY.TRANSLATED.NET/DOC/USAGELIMITS.PHP"})," TO TRANSLATE MORE"]})]})}function _(r={}){const{wrapper:e}={...(0,s.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(T,{...r})}):T(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>a,x:()=>i});var t=n(6540);const o={},s=t.createContext(o);function a(r){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function i(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:a(r.components),t.createElement(s.Provider,{value:e},r.children)}}}]);