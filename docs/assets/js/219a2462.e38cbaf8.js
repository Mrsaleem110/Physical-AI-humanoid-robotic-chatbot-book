"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[156],{8315:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-1/python-ros-control","title":"Python \u2192 ROS Control via rclpy","description":"Chapter Objectives","source":"@site/docs/module-1/python-ros-control.md","sourceDirName":"module-1","slug":"/module-1/python-ros-control","permalink":"/Physical-AI-humanoid-robotic-chatbot-book/docs/module-1/python-ros-control","draft":false,"unlisted":false,"editUrl":"https://github.com/Mrsaleem110/Physical-AI-humanoid-robotic-chatbot-book/tree/main/docs/docs/module-1/python-ros-control.md","tags":[],"version":"current","lastUpdatedBy":"muhammad_saleem","lastUpdatedAt":1765979454000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Nodes, Topics, and Services","permalink":"/Physical-AI-humanoid-robotic-chatbot-book/docs/module-1/ros2-nodes-topics-services"},"next":{"title":"URDF for Humanoid Robots","permalink":"/Physical-AI-humanoid-robotic-chatbot-book/docs/module-1/urdf-humanoid-robots"}}');var t=e(4848),i=e(8453);const l={sidebar_position:3},s="Python \u2192 ROS Control via rclpy",a={},c=[{value:"Chapter Objectives",id:"chapter-objectives",level:2},{value:"Introduction to rclpy",id:"introduction-to-rclpy",level:2},{value:"Key Features of rclpy",id:"key-features-of-rclpy",level:3},{value:"Installation and Setup",id:"installation-and-setup",level:3},{value:"Basic Node Structure with rclpy",id:"basic-node-structure-with-rclpy",level:2},{value:"Implementing Joint Control",id:"implementing-joint-control",level:2},{value:"Control Algorithms in Python",id:"control-algorithms-in-python",level:2},{value:"Working with ROS 2 Control",id:"working-with-ros-2-control",level:2},{value:"Asynchronous Programming with rclpy",id:"asynchronous-programming-with-rclpy",level:2},{value:"Best Practices for Humanoid Control",id:"best-practices-for-humanoid-control",level:2},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Safety Features",id:"safety-features",level:3},{value:"Code Organization",id:"code-organization",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2},{value:"Summary",id:"summary",level:2},{value:"Learning Path Adjustment",id:"learning-path-adjustment",level:2}];function d(r){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"python--ros-control-via-rclpy",children:"Python \u2192 ROS Control via rclpy"})}),"\n",(0,t.jsx)(n.h2,{id:"chapter-objectives",children:"Chapter Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Master Python-based ROS 2 development using rclpy"}),"\n",(0,t.jsx)(n.li,{children:"Implement robot control interfaces in Python"}),"\n",(0,t.jsx)(n.li,{children:"Create control nodes for humanoid robot actuators"}),"\n",(0,t.jsx)(n.li,{children:"Integrate with ROS 2 control frameworks"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"introduction-to-rclpy",children:"Introduction to rclpy"}),"\n",(0,t.jsx)(n.p,{children:"rclpy is the Python client library for ROS 2. It provides a Python API for creating ROS 2 nodes, publishers, subscribers, services, and actions."}),"\n",(0,t.jsx)(n.h3,{id:"key-features-of-rclpy",children:"Key Features of rclpy"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Object-oriented API that follows Python conventions"}),"\n",(0,t.jsx)(n.li,{children:"Asynchronous programming support with asyncio"}),"\n",(0,t.jsx)(n.li,{children:"Integration with Python's logging system"}),"\n",(0,t.jsx)(n.li,{children:"Support for all ROS 2 communication patterns"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,t.jsx)(n.p,{children:"rclpy is included with ROS 2 installations, but you can install additional Python packages:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"pip3 install rclpy\r\npip3 install transforms3d  # For 3D transformations\r\npip3 install numpy        # For numerical computations\n"})}),"\n",(0,t.jsx)(n.h2,{id:"basic-node-structure-with-rclpy",children:"Basic Node Structure with rclpy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.qos import QoSProfile\r\nimport sys\r\n\r\nclass RobotController(Node):\r\n    def __init__(self):\r\n        super().__init__('robot_controller')\r\n\r\n        # Create a QoS profile for reliable communication\r\n        qos_profile = QoSProfile(depth=10)\r\n\r\n        # Initialize controller parameters\r\n        self.joint_positions = {}\r\n        self.target_positions = {}\r\n\r\n        self.get_logger().info('Robot Controller initialized')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = RobotController()\r\n\r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        controller.get_logger().info('Shutting down robot controller...')\r\n    finally:\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"implementing-joint-control",children:"Implementing Joint Control"}),"\n",(0,t.jsx)(n.p,{children:"For humanoid robots, we need to control multiple joints. Let's create a joint controller:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\r\nfrom control_msgs.msg import JointTrajectoryControllerState\r\nimport math\r\nimport time\r\n\r\nclass JointController(Node):\r\n    def __init__(self):\r\n        super().__init__('joint_controller')\r\n\r\n        # Joint names for a humanoid robot\r\n        self.joint_names = [\r\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\r\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\r\n            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',\r\n            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint'\r\n        ]\r\n\r\n        # Current joint states\r\n        self.current_positions = {name: 0.0 for name in self.joint_names}\r\n        self.current_velocities = {name: 0.0 for name in self.joint_names}\r\n        self.current_efforts = {name: 0.0 for name in self.joint_names}\r\n\r\n        # Publishers and subscribers\r\n        self.joint_state_pub = self.create_publisher(JointState, 'joint_states', 10)\r\n        self.joint_command_sub = self.create_subscription(\r\n            JointTrajectory, 'joint_trajectory', self.joint_command_callback, 10)\r\n\r\n        # Timer for publishing joint states\r\n        self.timer = self.create_timer(0.05, self.publish_joint_states)  # 20 Hz\r\n\r\n        self.get_logger().info(f'Joint Controller initialized with {len(self.joint_names)} joints')\r\n\r\n    def joint_command_callback(self, msg):\r\n        \"\"\"Callback for joint trajectory commands\"\"\"\r\n        self.get_logger().info(f'Received trajectory with {len(msg.points)} points')\r\n\r\n        # For now, just execute the first point\r\n        if msg.points:\r\n            point = msg.points[0]\r\n            for i, joint_name in enumerate(msg.joint_names):\r\n                if joint_name in self.current_positions:\r\n                    self.current_positions[joint_name] = point.positions[i]\r\n                    if len(point.velocities) > i:\r\n                        self.current_velocities[joint_name] = point.velocities[i]\r\n                    if len(point.effort) > i:\r\n                        self.current_efforts[joint_name] = point.effort[i]\r\n\r\n    def publish_joint_states(self):\r\n        \"\"\"Publish current joint states\"\"\"\r\n        msg = JointState()\r\n        msg.name = list(self.current_positions.keys())\r\n        msg.position = list(self.current_positions.values())\r\n        msg.velocity = list(self.current_velocities.values())\r\n        msg.effort = list(self.current_efforts.values())\r\n        msg.header.stamp = self.get_clock().now().to_msg()\r\n        msg.header.frame_id = 'base_link'\r\n\r\n        self.joint_state_pub.publish(msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = JointController()\r\n\r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        controller.get_logger().info('Shutting down joint controller...')\r\n    finally:\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"control-algorithms-in-python",children:"Control Algorithms in Python"}),"\n",(0,t.jsx)(n.p,{children:"Let's implement a PID controller for joint position control:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class PIDController:\r\n    def __init__(self, kp=1.0, ki=0.0, kd=0.0, dt=0.01):\r\n        self.kp = kp  # Proportional gain\r\n        self.ki = ki  # Integral gain\r\n        self.kd = kd  # Derivative gain\r\n        self.dt = dt  # Time step\r\n\r\n        self.prev_error = 0.0\r\n        self.integral = 0.0\r\n\r\n    def compute(self, setpoint, measurement):\r\n        """Compute control output using PID algorithm"""\r\n        error = setpoint - measurement\r\n\r\n        # Proportional term\r\n        p_term = self.kp * error\r\n\r\n        # Integral term\r\n        self.integral += error * self.dt\r\n        i_term = self.ki * self.integral\r\n\r\n        # Derivative term\r\n        derivative = (error - self.prev_error) / self.dt\r\n        d_term = self.kd * derivative\r\n\r\n        # Store error for next iteration\r\n        self.prev_error = error\r\n\r\n        # Compute output\r\n        output = p_term + i_term + d_term\r\n\r\n        return output\r\n\r\nclass JointPIDController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'joint_pid_controller\')\r\n\r\n        # Initialize PID controllers for each joint\r\n        self.pid_controllers = {}\r\n        self.joint_names = [\r\n            \'left_hip_joint\', \'left_knee_joint\', \'left_ankle_joint\',\r\n            \'right_hip_joint\', \'right_knee_joint\', \'right_ankle_joint\'\r\n        ]\r\n\r\n        for joint_name in self.joint_names:\r\n            # Different PID parameters for different joints\r\n            if \'hip\' in joint_name:\r\n                self.pid_controllers[joint_name] = PIDController(kp=2.0, ki=0.1, kd=0.05)\r\n            elif \'knee\' in joint_name:\r\n                self.pid_controllers[joint_name] = PIDController(kp=1.5, ki=0.05, kd=0.03)\r\n            else:  # ankle\r\n                self.pid_controllers[joint_name] = PIDController(kp=1.0, ki=0.02, kd=0.01)\r\n\r\n        # Current states\r\n        self.current_positions = {name: 0.0 for name in self.joint_names}\r\n        self.target_positions = {name: 0.0 for name in self.joint_names}\r\n        self.control_outputs = {name: 0.0 for name in self.joint_names}\r\n\r\n        # Publishers and subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'joint_states\', self.joint_state_callback, 10)\r\n        self.control_pub = self.create_publisher(JointTrajectory, \'joint_trajectory\', 10)\r\n\r\n        # Timer for control loop (100 Hz)\r\n        self.control_timer = self.create_timer(0.01, self.control_loop)\r\n\r\n        self.get_logger().info(\'Joint PID Controller initialized\')\r\n\r\n    def joint_state_callback(self, msg):\r\n        """Update current joint positions"""\r\n        for i, name in enumerate(msg.name):\r\n            if name in self.current_positions:\r\n                self.current_positions[name] = msg.position[i]\r\n\r\n    def control_loop(self):\r\n        """Main control loop"""\r\n        for joint_name in self.joint_names:\r\n            current_pos = self.current_positions[joint_name]\r\n            target_pos = self.target_positions[joint_name]\r\n\r\n            # Compute control output using PID\r\n            control_output = self.pid_controllers[joint_name].compute(target_pos, current_pos)\r\n            self.control_outputs[joint_name] = control_output\r\n\r\n            # For this example, we\'ll just publish the target positions\r\n            # In a real system, you would convert the control output to actual motor commands\r\n\r\n        # Publish the desired trajectory\r\n        self.publish_trajectory_command()\r\n\r\n    def publish_trajectory_command(self):\r\n        """Publish trajectory command"""\r\n        msg = JointTrajectory()\r\n        msg.joint_names = self.joint_names\r\n\r\n        point = JointTrajectoryPoint()\r\n        point.positions = [self.target_positions[name] for name in self.joint_names]\r\n        point.velocities = [0.0] * len(self.joint_names)  # Zero velocity\r\n        point.time_from_start.sec = 0\r\n        point.time_from_start.nanosec = 50000000  # 50ms\r\n\r\n        msg.points = [point]\r\n        self.control_pub.publish(msg)\r\n\r\n    def set_target_positions(self, targets):\r\n        """Set target positions for joints"""\r\n        for joint_name, position in targets.items():\r\n            if joint_name in self.target_positions:\r\n                self.target_positions[joint_name] = position\n'})}),"\n",(0,t.jsx)(n.h2,{id:"working-with-ros-2-control",children:"Working with ROS 2 Control"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 Control is the standard framework for robot control. Let's see how to integrate with it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# my_robot_package/my_robot_package/humanoid_controller.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom controller_manager_msgs.srv import SwitchController\r\nfrom hardware_interface_msgs.msg import HardwareInterface\r\nimport time\r\n\r\nclass HumanoidController(Node):\r\n    def __init__(self):\r\n        super().__init__('humanoid_controller')\r\n\r\n        # Controller management client\r\n        self.switch_controller_client = self.create_client(\r\n            SwitchController, '/controller_manager/switch_controller')\r\n\r\n        # Wait for controller manager service\r\n        while not self.switch_controller_client.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info('Controller manager service not available, waiting...')\r\n\r\n        self.get_logger().info('Humanoid Controller initialized')\r\n\r\n    def switch_controllers(self, start_controllers, stop_controllers, strictness=1):\r\n        \"\"\"Switch between controllers\"\"\"\r\n        request = SwitchController.Request()\r\n        request.start_controllers = start_controllers\r\n        request.stop_controllers = stop_controllers\r\n        request.strictness = strictness\r\n\r\n        future = self.switch_controller_client.call_async(request)\r\n        rclpy.spin_until_future_complete(self, future)\r\n\r\n        if future.result() is not None:\r\n            response = future.result()\r\n            if response.ok:\r\n                self.get_logger().info(f'Successfully switched controllers')\r\n                return True\r\n            else:\r\n                self.get_logger().error(f'Failed to switch controllers: {response.error_message}')\r\n                return False\r\n        else:\r\n            self.get_logger().error('Failed to call controller manager service')\r\n            return False\r\n\r\n    def initialize_robot(self):\r\n        \"\"\"Initialize the robot by starting necessary controllers\"\"\"\r\n        self.get_logger().info('Initializing humanoid robot...')\r\n\r\n        # Start joint state broadcaster\r\n        success = self.switch_controllers(\r\n            start_controllers=['joint_state_broadcaster'],\r\n            stop_controllers=[]\r\n        )\r\n\r\n        if success:\r\n            time.sleep(1.0)  # Wait for controller to start\r\n\r\n            # Start position controllers for all joints\r\n            position_controllers = [\r\n                'left_leg_position_controller',\r\n                'right_leg_position_controller',\r\n                'left_arm_position_controller',\r\n                'right_arm_position_controller',\r\n                'head_position_controller'\r\n            ]\r\n\r\n            success = self.switch_controllers(\r\n                start_controllers=position_controllers,\r\n                stop_controllers=[]\r\n            )\r\n\r\n        if success:\r\n            self.get_logger().info('Robot initialized successfully')\r\n        else:\r\n            self.get_logger().error('Failed to initialize robot')\r\n\r\n        return success\n"})}),"\n",(0,t.jsx)(n.h2,{id:"asynchronous-programming-with-rclpy",children:"Asynchronous Programming with rclpy"}),"\n",(0,t.jsx)(n.p,{children:"rclpy supports asyncio for more complex control patterns:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\r\nimport asyncio\r\n\r\nclass AsyncController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'async_controller\')\r\n\r\n        # Create callback groups for threading\r\n        self.group1 = MutuallyExclusiveCallbackGroup()\r\n        self.group2 = MutuallyExclusiveCallbackGroup()\r\n\r\n        # Create timers with different callback groups\r\n        self.timer1 = self.create_timer(0.1, self.async_task1, callback_group=self.group1)\r\n        self.timer2 = self.create_timer(0.2, self.async_task2, callback_group=self.group2)\r\n\r\n    def async_task1(self):\r\n        """Asynchronous task 1"""\r\n        self.get_logger().info(\'Executing async task 1\')\r\n        # Simulate some work\r\n        time.sleep(0.05)\r\n\r\n    def async_task2(self):\r\n        """Asynchronous task 2"""\r\n        self.get_logger().info(\'Executing async task 2\')\r\n        # Simulate some work\r\n        time.sleep(0.03)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = AsyncController()\r\n\r\n    # Use multi-threaded executor for async operations\r\n    executor = MultiThreadedExecutor(num_threads=4)\r\n    executor.add_node(node)\r\n\r\n    try:\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'Shutting down async controller...\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-for-humanoid-control",children:"Best Practices for Humanoid Control"}),"\n",(0,t.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use appropriate control frequencies (typically 100-1000 Hz for joint control)"}),"\n",(0,t.jsx)(n.li,{children:"Minimize computational overhead in control loops"}),"\n",(0,t.jsx)(n.li,{children:"Use efficient data structures for joint management"}),"\n",(0,t.jsx)(n.li,{children:"Consider real-time capabilities for critical control tasks"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"safety-features",children:"Safety Features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Implement joint position and velocity limits"}),"\n",(0,t.jsx)(n.li,{children:"Add emergency stop functionality"}),"\n",(0,t.jsx)(n.li,{children:"Monitor control effort to detect issues"}),"\n",(0,t.jsx)(n.li,{children:"Implement graceful degradation when problems occur"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"code-organization",children:"Code Organization"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Separate control logic from ROS 2 communication"}),"\n",(0,t.jsx)(n.li,{children:"Use configuration files for controller parameters"}),"\n",(0,t.jsx)(n.li,{children:"Implement proper error handling and logging"}),"\n",(0,t.jsx)(n.li,{children:"Create reusable controller components"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create a Python node that controls a simple humanoid robot model"}),"\n",(0,t.jsx)(n.li,{children:"Implement PID controllers for at least 6 joints"}),"\n",(0,t.jsx)(n.li,{children:"Create a trajectory publisher that moves the robot through a simple motion"}),"\n",(0,t.jsx)(n.li,{children:"Add safety limits to prevent joint damage"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Python provides a powerful platform for ROS 2 robot control through rclpy. With proper control algorithms and integration with ROS 2 Control, you can create sophisticated humanoid robot controllers. In the next chapter, we'll explore URDF for humanoid robot modeling."}),"\n",(0,t.jsx)(n.h2,{id:"learning-path-adjustment",children:"Learning Path Adjustment"}),"\n",(0,t.jsx)(n.p,{children:"Based on your experience level, you may want to focus on:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Beginner"}),": Focus on basic node creation and simple control loops"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Intermediate"}),": Dive deeper into PID control and trajectory generation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Advanced"}),": Explore real-time control, advanced control algorithms, and system integration"]}),"\n"]})]})}function p(r={}){const{wrapper:n}={...(0,i.R)(),...r.components};return n?(0,t.jsx)(n,{...r,children:(0,t.jsx)(d,{...r})}):d(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>l,x:()=>s});var o=e(6540);const t={},i=o.createContext(t);function l(r){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof r?r(n):{...n,...r}},[n,r])}function s(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:l(r.components),o.createElement(i.Provider,{value:n},r.children)}}}]);